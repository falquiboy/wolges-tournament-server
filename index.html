<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Torneo de Scrabble Duplicado - v16</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        /* Modal para leaderboard final */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            animation: fadeIn 0.3s;
        }
        
        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 30px;
            border: 1px solid #888;
            width: 80%;
            max-width: 800px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            animation: slideIn 0.5s;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .game-over-header {
            text-align: center;
            font-size: 36px;
            color: #27ae60;
            margin-bottom: 20px;
            font-weight: bold;
        }
        
        .game-over-reason {
            text-align: center;
            font-size: 18px;
            color: #666;
            margin-bottom: 30px;
        }
        
        .final-leaderboard {
            width: 100%;
            margin: 20px 0;
        }
        
        .final-leaderboard th {
            background: #2c3e50;
            color: white;
            padding: 15px;
            font-size: 18px;
        }
        
        .final-leaderboard td {
            padding: 12px;
            font-size: 16px;
            text-align: center;
        }
        
        .final-leaderboard tr:nth-child(1) {
            background: #ffd700;
            font-weight: bold;
            font-size: 20px;
        }
        
        .final-leaderboard tr:nth-child(2) {
            background: #c0c0c0;
        }
        
        .final-leaderboard tr:nth-child(3) {
            background: #cd7f32;
        }
        
        .close-modal {
            background: #3498db;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            display: block;
            margin: 20px auto 0;
        }
        
        .close-modal:hover {
            background: #2980b9;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        h1 {
            text-align: center;
            color: white;
            font-size: 2.5em;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .game-layout {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 20px;
            align-items: start;
        }

        .panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        /* Tablero de Scrabble */
        .board-container {
            background: #2c3e50;
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            display: inline-block;
            position: relative;
        }
        
        .board-wrapper {
            display: grid;
            grid-template-columns: 30px 1fr 30px;
            grid-template-rows: 30px 1fr 30px;
            gap: 2px;
        }
        
        .board-grid {
            display: grid;
            grid-template-columns: repeat(15, 32px);
            gap: 0;
            background: #34495e;
            padding: 1px;
            position: relative;
            grid-column: 2;
            grid-row: 2;
        }

        .coordinates {
            display: grid;
            gap: 2px;
        }
        
        .coordinates.top {
            grid-template-columns: repeat(15, 32px);
            grid-column: 2;
            grid-row: 1;
            gap: 0;
            padding: 0 1px;
        }
        
        .coordinates.bottom {
            grid-template-columns: repeat(15, 32px);
            grid-column: 2;
            grid-row: 3;
            gap: 0;
            padding: 0 1px;
        }
        
        .coordinates.left {
            grid-template-rows: repeat(15, 32px);
            grid-column: 1;
            grid-row: 2;
            gap: 0;
            padding: 1px 0;
        }
        
        .coordinates.right {
            grid-template-rows: repeat(15, 32px);
            grid-column: 3;
            grid-row: 2;
            gap: 0;
            padding: 1px 0;
        }

        .coord {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #ecf0f1;
            font-size: 12px;
            font-weight: bold;
        }
        
        .corner {
            width: 30px;
            height: 30px;
        }

        .board-row {
            display: contents;
        }

        .cell {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            background: #007778;
            color: white;
            border: none;
            box-shadow: inset 2px 2px 0 rgba(0,0,0,0.15), inset -2px -2px 0 rgba(255,255,255,0.15);
        }

        .cell:hover {
            transform: scale(1.1);
            z-index: 10;
        }

        /* Casillas premium */
        .tw { 
            background: #e53935 !important;
            color: white !important;
        }
        .dw { 
            background: #e5a2a0 !important;
            color: white !important;
        }
        .tl { 
            background: #408bf4 !important;
            color: white !important;
        }
        .dl { 
            background: #9dcaf0 !important;
            color: #2c3e50 !important;
        }
        .star { 
            background: #e5a2a0 !important;
            color: white !important;
        }

        .premium-label {
            font-size: 12px;
            font-weight: bold;
            opacity: 0.9;
            color: white !important;
        }

        /* Fichas colocadas */
        .cell.filled {
            background: #fef9d3 !important;
            color: #2d7a3e !important;
            outline: 1px solid #e8d7c3;
            outline-offset: -1px;
            font-size: 20px;
            border-radius: 2px;
            position: relative;
            padding-bottom: 3px;
            padding-right: 3px;
        }
        
        /* Tama√±o m√°s peque√±o para d√≠grafos */
        .cell.filled.digraph {
            font-size: 16px;
        }
        
        /* Comodines (letras min√∫sculas) */
        .cell.filled.blank {
            color: #e74c3c !important;
            font-weight: bold;
            text-transform: lowercase;
        }

        /* Valores de las fichas */
        .tile-value {
            position: absolute;
            bottom: 2px;
            right: 3px;
            font-size: 8px;
            font-weight: bold;
            color: #2d7a3e;
            line-height: 1;
        }

        .rack-tile .tile-value {
            font-size: 10px;
            bottom: 3px;
            right: 4px;
        }

        .cell.highlight {
            animation: shimmer 3s ease-in-out infinite;
            position: relative;
            overflow: hidden;
        }
        
        /* Contorno naranja para la palabra completa */
        .word-outline {
            position: absolute;
            border: 2px solid #ff6b35;
            box-shadow: 0 0 8px rgba(255, 107, 53, 0.5);
            pointer-events: none;
            z-index: 10;
            border-radius: 2px;
        }
        
        .cell.highlight::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, 
                transparent 30%, 
                rgba(255, 255, 255, 0.5) 50%, 
                transparent 70%);
            transform: translateX(-100%);
            animation: shine 3s ease-in-out infinite;
        }

        @keyframes shimmer {
            0% { 
                transform: scale(1) rotate(0deg);
                filter: brightness(0.85);
            }
            20% { 
                transform: scale(1.03) rotate(0.5deg);
                filter: brightness(0.9);
            }
            40% { 
                transform: scale(1.05) rotate(-0.5deg);
                filter: brightness(0.95);
            }
            50% { 
                transform: scale(1.05) rotate(0deg);
                filter: brightness(1);
            }
            60% { 
                transform: scale(1.03) rotate(0.5deg);
                filter: brightness(0.95);
            }
            80% { 
                transform: scale(1.01) rotate(0deg);
                filter: brightness(0.9);
            }
            100% { 
                transform: scale(1) rotate(0deg);
                filter: brightness(0.85);
            }
        }
        
        @keyframes shine {
            0% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
            100% { transform: translateX(100%); }
        }

        /* Atril */
        .rack-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 20px 0;
        }

        .rack {
            display: flex;
            gap: 8px;
            padding: 12px;
            background: #2d5a3d;
            border-radius: 10px;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.3);
            width: 440px;
            min-height: 72px;
            justify-content: center;
            align-items: center;
        }

        .rack-tile {
            width: 48px;
            height: 48px;
            background: #fef9d3;
            border: 1px solid #e8d7c3;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            font-weight: bold;
            color: #2d7a3e;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            flex-shrink: 0;
            position: relative;
            padding-bottom: 4px;
            padding-right: 4px;
        }
        
        /* Tama√±o m√°s peque√±o para d√≠grafos en rack */
        .rack-tile.digraph {
            font-size: 20px;
        }
        
        /* Estilos para drag and drop */
        .rack-tile {
            cursor: grab;
            transition: transform 0.2s;
        }
        
        .rack-tile:active {
            cursor: grabbing;
        }
        
        .rack-tile.dragging {
            opacity: 0.5;
            transform: scale(1.1);
            z-index: 1000;
        }
        
        .rack-tile.drag-over {
            transform: translateX(15px);
            background: rgba(52, 152, 219, 0.2);
        }
        
        .rack {
            position: relative;
        }
        
        .drag-placeholder {
            width: 3px;
            height: 60px;
            background: #ff6b35;
            position: absolute;
            top: 0;
            transition: left 0.2s;
            pointer-events: none;
        }
        
        /* Animaci√≥n de deslizamiento para fichas */
        .rack-tile.slide-out {
            animation: slideOut 0.5s ease-out forwards;
        }
        
        .rack-tile.slide-in {
            animation: slideIn 0.5s ease-out forwards;
        }
        
        @keyframes slideOut {
            0% {
                transform: translateX(0);
                opacity: 1;
            }
            100% {
                transform: translateX(-100px);
                opacity: 0;
            }
        }
        
        @keyframes slideIn {
            0% {
                transform: translateX(100px);
                opacity: 0;
            }
            100% {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Botones */
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }

        button:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin: 15px 0;
        }

        /* Informaci√≥n del juego */
        .info-section {
            margin: 15px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .info-section h3 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        /* Jugada √≥ptima */
        .optimal-play {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        /* Tabla de posiciones */
        .leaderboard {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        .leaderboard th {
            background: #3498db;
            color: white;
            padding: 12px;
            text-align: left;
        }

        .leaderboard td {
            padding: 10px 12px;
            border-bottom: 1px solid #ddd;
        }

        .leaderboard tr:nth-child(even) {
            background: #f8f9fa;
        }

        .leaderboard tr:hover {
            background: #e3f2fd;
        }

        /* Estados */
        .status {
            padding: 10px 15px;
            border-radius: 6px;
            margin: 10px 0;
            font-weight: 500;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        /* Fichas de la bolsa */
        .bag-tiles {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            margin: 10px 0;
        }
        
        .bag-tile {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            border: 1px solid #d4a574;
            border-radius: 3px;
            background: #fff8dc;
            color: #2c3e50;
        }
        
        .bag-tile.used {
            opacity: 0.3;
            background: #e0e0e0;
        }
        
        /* Tabla del Master */
        .master-plays {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        
        .master-plays th {
            background: #f39c12;
            color: white;
            padding: 8px;
            text-align: left;
            font-size: 14px;
        }
        
        .master-plays td {
            padding: 6px 8px;
            border-bottom: 1px solid #ddd;
            font-size: 14px;
        }
        
        .master-plays tr:nth-child(even) {
            background: #fffaf0;
        }

        /* Responsive */
        @media (max-width: 1400px) {
            .game-layout {
                grid-template-columns: 1fr;
            }
            
            .board-container {
                order: 2;
                margin: 0 auto;
            }
            
            .panel {
                max-width: 600px;
                margin: 0 auto;
            }
        }

        /* Toggle bonus tags */
        .bonus-toggle {
            position: absolute;
            bottom: 8px;
            right: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
            color: #ecf0f1;
            font-size: 12px;
        }

        .toggle-switch {
            position: relative;
            width: 40px;
            height: 22px;
            background: #34495e;
            border-radius: 22px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: #3498db;
        }

        .toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }

        .toggle-switch.active .toggle-slider {
            transform: translateX(18px);
        }

        .premium-label.hidden, 
        .cell.star img.hidden {
            display: none !important;
        }
        @keyframes pulse {
            0% {
                transform: scale(1);
                box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            }
            50% {
                transform: scale(1.02);
                box-shadow: 0 6px 20px rgba(0,0,0,0.4);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            }
        }
        
        /* Modal para cargar torneos */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        
        .modal-content {
            background-color: #fefefe;
            margin: 10% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 600px;
            border-radius: 10px;
            max-height: 70vh;
            overflow-y: auto;
        }
        
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .close:hover,
        .close:focus {
            color: black;
        }
        
        .tournament-item {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .tournament-item:hover {
            background: #e9ecef;
            transform: translateX(5px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .tournament-item h4 {
            margin: 0 0 10px 0;
            color: #2c3e50;
        }
        
        .tournament-item .info {
            color: #6c757d;
            font-size: 14px;
        }
        
        .tournament-item .status {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 10px;
        }
        
        .status.active {
            background: #d4edda;
            color: #155724;
        }
        
        .status.finished {
            background: #f8d7da;
            color: #721c24;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <h1>üéØ Torneo de Scrabble Duplicado üöÄ</h1>
        
        <div class="game-layout">
            <!-- Panel Izquierdo -->
            <div class="panel">
                <!-- Timer y Controles del Juego (aparece despu√©s de crear torneo) -->
                <div id="gameControlsTop" style="display:none; margin-bottom: 20px;">
                    <div class="timer-section" style="background: #2c3e50; color: white; padding: 15px; border-radius: 10px; text-align: center; margin: -10px -10px 15px -10px;">
                        <div id="timerDisplay" style="font-size: 48px; font-weight: bold; font-family: monospace;">3:00</div>
                        <div style="font-size: 14px; color: #bdc3c7; margin-top: 5px;">Tiempo de reflexi√≥n</div>
                    </div>
                    
                    <div class="game-actions" style="margin-bottom: 15px;">
                        <button onclick="handleUniversalAction()" id="universalBtn" style="background: #27ae60; color: white; padding: 12px; border-radius: 5px; font-size: 16px; width: 100%; margin-bottom: 8px; font-weight: bold; transition: all 0.3s;">
                            üé≤ Generar Atril de la Ronda 1
                        </button>
                        <button onclick="checkAndShowFinalLeaderboard()" style="background: #34495e; color: white; padding: 8px 12px; border-radius: 5px; font-size: 14px; width: 100%;">
                            üìä Ver Tabla de Posiciones
                        </button>
                    </div>
                    
                    
                    <!-- Entrada Manual de Atril -->
                    <div class="info-section" id="manualRackSection" style="display:none;">
                        <h3>Entrada Manual de Atril</h3>
                        <div id="manualRackInput">
                            <input type="text" id="manualRack" placeholder="Ej: CASA o CA?A (? = comod√≠n)" 
                                   style="width: 100%; padding: 8px; text-transform: uppercase; margin-bottom: 10px;"
                                   oninput="validateManualRack()">
                            <button onclick="useManualRack()" id="useManualBtn" style="background: #3498db; width: 100%;">
                                Usar Atril Manual
                            </button>
                            <div id="rackValidationMessage" style="font-size: 12px; margin-top: 5px; min-height: 20px;">
                                <span style="color: #666;">Escriba las letras. Los d√≠grafos CH, LL, RR cuentan como 1 ficha.</span>
                            </div>
                        </div>
                        <div id="tilesRemaining" style="margin-top: 10px; font-weight: bold;"></div>
                    </div>
                </div>
                
                <h2>Configuraci√≥n</h2>
                
                <div class="info-section">
                    <h3>1. Diccionario</h3>
                    <button onclick="loadDictionary()" id="loadDictBtn">Cargar FISE2016</button>
                    <div id="dictStatus"></div>
                </div>

                <div class="info-section">
                    <h3>2. Gesti√≥n de Torneos</h3>
                    <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                        <button onclick="showNewTournamentForm()" style="flex: 1; background: #27ae60;">
                            üÜï Nuevo Torneo
                        </button>
                        <button onclick="showLoadTournamentModal()" style="flex: 1; background: #3498db;">
                            üìÇ Cargar Torneo
                        </button>
                    </div>
                    
                    <div id="newTournamentForm" style="display: none;">
                        <input type="text" id="tournamentName" placeholder="Nombre del torneo" 
                               value="Torneo de Cuates" style="width: 100%; padding: 8px; margin: 5px 0;">
                        <input type="text" id="playerNames" placeholder="Jugadores (separados por coma)" 
                               value="Juan, Mar√≠a, Carlos, Ana" style="width: 100%; padding: 8px; margin: 5px 0;">
                        <button onclick="createTournament()" id="createBtn">Crear Torneo</button>
                    </div>
                </div>

                <div class="info-section" id="tournamentInfo" style="display:none; background: #e8f6ff; border: 2px solid #3498db;">
                    <h3>üéÆ Torneo Creado</h3>
                    <div style="margin: 15px 0;">
                        <strong>ID del Torneo:</strong>
                        <div id="tournamentId" style="font-family: monospace; font-size: 14px; margin: 5px 0; padding: 5px; background: #fff; border: 1px solid #ddd; border-radius: 4px;"></div>
                    </div>
                    <div style="margin: 15px 0;">
                        <strong>Enlace para Jugadores:</strong>
                        <div id="playerLink" style="font-size: 14px; margin: 5px 0; padding: 8px; background: #fff; border: 1px solid #ddd; border-radius: 4px; word-break: break-all;">
                            <a href="#" target="_blank" style="color: #3498db;"></a>
                        </div>
                        <button onclick="copyPlayerLink()" style="background: #27ae60; padding: 5px 15px; font-size: 14px;">
                            üìã Copiar Enlace
                        </button>
                    </div>
                </div>

                
            </div>

            <!-- Tablero Central -->
            <div class="board-container">
                <div class="bonus-toggle">
                    <span>Bonus</span>
                    <div class="toggle-switch active" id="bonusToggle" onclick="toggleBonusTags()">
                        <div class="toggle-slider"></div>
                    </div>
                </div>
                <div class="board-wrapper">
                    <!-- Esquina superior izquierda -->
                    <div class="corner" style="grid-column: 1; grid-row: 1;"></div>
                    
                    <!-- Coordenadas superiores (n√∫meros) -->
                    <div class="coordinates top">
                        <div class="coord">1</div>
                        <div class="coord">2</div>
                        <div class="coord">3</div>
                        <div class="coord">4</div>
                        <div class="coord">5</div>
                        <div class="coord">6</div>
                        <div class="coord">7</div>
                        <div class="coord">8</div>
                        <div class="coord">9</div>
                        <div class="coord">10</div>
                        <div class="coord">11</div>
                        <div class="coord">12</div>
                        <div class="coord">13</div>
                        <div class="coord">14</div>
                        <div class="coord">15</div>
                    </div>
                    
                    <!-- Esquina superior derecha -->
                    <div class="corner" style="grid-column: 3; grid-row: 1;"></div>
                    
                    <!-- Coordenadas izquierdas (letras) -->
                    <div class="coordinates left" id="leftCoords"></div>
                    
                    <!-- Tablero principal -->
                    <div id="board" class="board-grid"></div>
                    
                    <!-- Coordenadas derechas (letras) -->
                    <div class="coordinates right" id="rightCoords"></div>
                    
                    <!-- Esquina inferior izquierda -->
                    <div class="corner" style="grid-column: 1; grid-row: 3;"></div>
                    
                    <!-- Coordenadas inferiores (n√∫meros) -->
                    <div class="coordinates bottom">
                        <div class="coord">1</div>
                        <div class="coord">2</div>
                        <div class="coord">3</div>
                        <div class="coord">4</div>
                        <div class="coord">5</div>
                        <div class="coord">6</div>
                        <div class="coord">7</div>
                        <div class="coord">8</div>
                        <div class="coord">9</div>
                        <div class="coord">10</div>
                        <div class="coord">11</div>
                        <div class="coord">12</div>
                        <div class="coord">13</div>
                        <div class="coord">14</div>
                        <div class="coord">15</div>
                    </div>
                    
                    <!-- Esquina inferior derecha -->
                    <div class="corner" style="grid-column: 3; grid-row: 3;"></div>
                </div>
                
                <!-- Atril -->
                <div class="rack-container">
                    <div id="rack" class="rack" style="display:none;"></div>
                    <button id="shuffleBtn" onclick="shuffleRack()" style="display:none; margin-left: 15px; padding: 10px 15px; background: #3498db; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 24px; transition: all 0.3s; box-shadow: 0 2px 5px rgba(0,0,0,0.2);" title="Revolver fichas" onmouseover="this.style.background='#2980b9'; this.style.transform='scale(1.1)'" onmouseout="this.style.background='#3498db'; this.style.transform='scale(1)'">
                        üîÄ
                    </button>
                </div>
            </div>

            <!-- Panel Derecho -->
            <div class="panel">
                <h2>Informaci√≥n de la Ronda</h2>
                
                <div id="bagTilesContainer" style="display:none;">
                    <h3>Fichas de la Bolsa</h3>
                    <div id="bagTiles" class="bag-tiles"></div>
                </div>
                
                <div id="roundInfo"></div>
                <div id="optimalPlay"></div>
                
                <div id="masterPlaysContainer" style="display:none;">
                    <h3>üèÜ Jugador Master</h3>
                    <table id="masterPlays" class="master-plays">
                        <thead>
                            <tr>
                                <th>Ronda</th>
                                <th>Pos</th>
                                <th>Palabra</th>
                                <th>Puntos</th>
                                <th>Total</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
                
                <h3>Tabla de Posiciones</h3>
                <div id="leaderboard"></div>
            </div>
        </div>
    </div>
    
    <!-- Modal para cargar torneos -->
    <div id="loadTournamentModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeLoadModal()">&times;</span>
            <h2>üìÇ Cargar Torneo Guardado</h2>
            <div id="tournamentsList" style="margin-top: 20px;">
                <p style="text-align: center; color: #6c757d;">Cargando torneos...</p>
            </div>
        </div>
    </div>

    <script>
        let currentTournamentId = null;
        let currentRound = null;
        let timerInterval = null;
        let timeRemaining = 180; // 3 minutos en segundos
        let optimalPlayData = null; // Almacenar jugada √≥ptima sin mostrar
        const API_BASE = window.location.origin;
        
        // Estados del bot√≥n universal
        const BUTTON_STATES = {
            GENERATE_RACK: 'GENERATE_RACK',
            INVALID_RACK: 'INVALID_RACK', 
            START_ROUND: 'START_ROUND',
            REVEAL_PLAY: 'REVEAL_PLAY',
            GAME_OVER: 'GAME_OVER'
        };
        
        let currentButtonState = BUTTON_STATES.GENERATE_RACK;
        let currentRackIsValid = false;

        // Valores de las fichas del Scrabble espa√±ol
        const tileValues = {
            'A': 1, 'E': 1, 'I': 1, 'O': 1, 'U': 1, 'N': 1, 'R': 1, 'S': 1, 'T': 1, 'L': 1,
            'D': 2, 'G': 2,
            'B': 3, 'C': 3, 'M': 3, 'P': 3,
            'F': 4, 'H': 4, 'V': 4, 'Y': 4,
            'Q': 5,
            'J': 8, 'X': 8,
            'Z': 10,
            '√ë': 8,
            'CH': 5, 'LL': 8, 'RR': 8,
            '?': 0  // Comod√≠n
        };
        
        // Funci√≥n para obtener el valor de una ficha
        function getTileValue(letter) {
            // Convertir notaci√≥n de corchetes a letras
            const normalizedLetter = letter
                .replace('[CH]', 'CH')
                .replace('[LL]', 'LL')
                .replace('[RR]', 'RR')
                .toUpperCase();
            return tileValues[normalizedLetter] || 0;
        }

        // Definir casillas premium
        const premiumSquares = {
            // Triple Word
            '0,0': 'tw', '0,7': 'tw', '0,14': 'tw',
            '7,0': 'tw', '7,14': 'tw',
            '14,0': 'tw', '14,7': 'tw', '14,14': 'tw',
            // Double Word
            '1,1': 'dw', '2,2': 'dw', '3,3': 'dw', '4,4': 'dw',
            '1,13': 'dw', '2,12': 'dw', '3,11': 'dw', '4,10': 'dw',
            '13,1': 'dw', '12,2': 'dw', '11,3': 'dw', '10,4': 'dw',
            '13,13': 'dw', '12,12': 'dw', '11,11': 'dw', '10,10': 'dw',
            '7,7': 'star',
            // Triple Letter
            '1,5': 'tl', '1,9': 'tl', '5,1': 'tl', '5,5': 'tl',
            '5,9': 'tl', '5,13': 'tl', '9,1': 'tl', '9,5': 'tl',
            '9,9': 'tl', '9,13': 'tl', '13,5': 'tl', '13,9': 'tl',
            // Double Letter
            '0,3': 'dl', '0,11': 'dl', '2,6': 'dl', '2,8': 'dl',
            '3,0': 'dl', '3,7': 'dl', '3,14': 'dl', '6,2': 'dl',
            '6,6': 'dl', '6,8': 'dl', '6,12': 'dl', '7,3': 'dl',
            '7,11': 'dl', '8,2': 'dl', '8,6': 'dl', '8,8': 'dl',
            '8,12': 'dl', '11,0': 'dl', '11,7': 'dl', '11,14': 'dl',
            '12,6': 'dl', '12,8': 'dl', '14,3': 'dl', '14,11': 'dl'
        };

        const premiumLabels = {
            'tw': '3P', 'dw': '2P', 'tl': '3L', 'dl': '2L', 'star': '‚ú¶'
        };

        async function apiCall(method, endpoint, body = null) {
            try {
                const options = {
                    method: method,
                    headers: { 'Content-Type': 'application/json' }
                };
                if (body) options.body = JSON.stringify(body);
                
                const response = await fetch(`${API_BASE}${endpoint}`, options);
                const data = await response.json();
                
                return data;
            } catch (error) {
                console.error('API Error:', error);
                return { success: false, error: error.message };
            }
        }

        function showStatus(message, type = 'success', elementId = null) {
            const html = `<div class="status ${type}">${message}</div>`;
            if (elementId) {
                document.getElementById(elementId).innerHTML = html;
            }
        }

        async function loadDictionary() {
            document.getElementById('loadDictBtn').disabled = true;
            const result = await apiCall('POST', '/dictionary/load', {
                kwg_path: 'FISE2016_converted.kwg',
                klv_path: null
            });
            
            if (result.success) {
                showStatus('‚úÖ Diccionario FISE2016 cargado', 'success', 'dictStatus');
                document.getElementById('loadDictBtn').textContent = '‚úì Cargado';
            } else {
                showStatus('‚ùå ' + result.error, 'error', 'dictStatus');
                document.getElementById('loadDictBtn').disabled = false;
            }
        }

        async function createTournament() {
            const name = document.getElementById('tournamentName').value;
            const playerNames = document.getElementById('playerNames').value
                .split(',')
                .map(n => n.trim())
                .filter(n => n);
            
            if (!name || playerNames.length < 1) {
                alert('Necesitas al menos 1 jugador');
                return;
            }
            
            const result = await apiCall('POST', '/tournament/create', {
                name: name,
                player_names: playerNames
            });
            
            console.log('Create tournament result:', result);
            
            if (result.success && result.data) {
                currentTournamentId = result.data.id;
                console.log('Tournament ID set to:', currentTournamentId);
                
                // Mostrar informaci√≥n del torneo
                document.getElementById('tournamentInfo').style.display = 'block';
                document.getElementById('tournamentId').textContent = currentTournamentId;
                
                const playerUrl = `${window.location.origin}/player.html?t=${currentTournamentId}`;
                const linkElement = document.querySelector('#playerLink a');
                linkElement.href = playerUrl;
                linkElement.textContent = playerUrl;
                
                // Mostrar controles superiores del juego
                document.getElementById('gameControlsTop').style.display = 'block';
                document.getElementById('createBtn').disabled = true;
                document.getElementById('bagTilesContainer').style.display = 'block';
                document.getElementById('masterPlaysContainer').style.display = 'block';
                initializeBoard();
                updateLeaderboard();
                updateBagTiles();
                updateMasterPlays();
                
                // Inicializar el bot√≥n universal
                updateUniversalButton(BUTTON_STATES.GENERATE_RACK);
            }
        }

        function initializeBoard() {
            const board = document.getElementById('board');
            const leftCoords = document.getElementById('leftCoords');
            const rightCoords = document.getElementById('rightCoords');
            const letters = 'ABCDEFGHIJKLMNO';
            
            board.innerHTML = '';
            leftCoords.innerHTML = '';
            rightCoords.innerHTML = '';
            
            // Generar coordenadas laterales
            for (let row = 0; row < 15; row++) {
                // Coordenada izquierda
                const leftCoord = document.createElement('div');
                leftCoord.className = 'coord';
                leftCoord.textContent = letters[row];
                leftCoords.appendChild(leftCoord);
                
                // Coordenada derecha
                const rightCoord = document.createElement('div');
                rightCoord.className = 'coord';
                rightCoord.textContent = letters[row];
                rightCoords.appendChild(rightCoord);
                
                // Fila del tablero
                const boardRow = document.createElement('div');
                boardRow.className = 'board-row';
                
                // Celdas
                for (let col = 0; col < 15; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = `cell-${row * 15 + col}`;
                    
                    const premium = premiumSquares[`${row},${col}`];
                    if (premium) {
                        cell.classList.add(premium);
                        if (premium === 'star') {
                            const img = document.createElement('img');
                            img.src = 'black_star.png';
                            img.style.width = '20px';
                            img.style.height = '20px';
                            cell.appendChild(img);
                        } else {
                            const label = document.createElement('span');
                            label.className = 'premium-label';
                            label.textContent = premiumLabels[premium];
                            cell.appendChild(label);
                        }
                    }
                    
                    boardRow.appendChild(cell);
                }
                
                board.appendChild(boardRow);
            }
        }

        // Nueva funci√≥n para generar atril
        async function generateNewRack() {
            console.log('generateNewRack called with tournament ID:', currentTournamentId);
            if (!currentTournamentId) {
                console.error('No tournament ID set!');
                return;
            }
            
            const result = await apiCall('POST', `/tournament/${currentTournamentId}/round/start`);
            console.log('generateNewRack result:', result);
            
            if (result.success && result.data) {
                currentRound = result.data;
                
                // Mostrar info de la ronda
                document.getElementById('roundInfo').innerHTML = `
                    <div class="info-section">
                        <h3>Ronda ${result.data.number}</h3>
                    </div>
                `;
                
                // Mostrar atril
                displayRack(result.data.rack);
                
                // Actualizar tablero
                updateBoard(result.data.board_state);
                
                // Verificar si el atril es v√°lido
                const isValid = checkRackValidity(result.data);
                currentRackIsValid = isValid;
                
                if (isValid) {
                    // Atril v√°lido - cambiar bot√≥n a "Iniciar Ronda"
                    updateUniversalButton(BUTTON_STATES.START_ROUND);
                } else {
                    // Atril inv√°lido - mostrar notificaci√≥n y cambiar bot√≥n
                    showInvalidRackNotification(result.data);
                    updateUniversalButton(BUTTON_STATES.INVALID_RACK);
                }
                
                // Actualizar fichas restantes
                updateTilesRemaining();
                updateBagTiles();
            }
        }
        
        // Funci√≥n para verificar validez del atril
        function checkRackValidity(round) {
            const tiles = round.rack.split('');
            const vowels = tiles.filter(t => 'AEIOU'.includes(t)).length;
            const consonants = tiles.filter(t => t !== '?' && !'AEIOU'.includes(t)).length;
            
            // Rondas 1-15: m√≠nimo 2 vocales y 2 consonantes
            // Rondas 16+: al menos 1 vocal o 1 consonante
            if (round.number <= 15) {
                return vowels >= 2 && consonants >= 2;
            } else {
                return vowels >= 1 || consonants >= 1;
            }
        }
        
        // Funci√≥n para iniciar la ronda con timer
        async function startRoundWithTimer() {
            if (!currentRackIsValid || !currentRound) return;
            
            // Ocultar entrada manual
            document.getElementById('manualRackSection').style.display = 'none';
            
            // Obtener jugada √≥ptima (sin mostrar)
            await getOptimalPlay(false);
            
            // Iniciar timer
            startTimer();
            
            // Cambiar bot√≥n a "Revelar Jugada"
            updateUniversalButton(BUTTON_STATES.REVEAL_PLAY);
            
            // Habilitar env√≠o de jugadas para los jugadores
            // (esto se maneja en player.html)
        }
        
        // Mantener la funci√≥n original para compatibilidad
        async function startNewRound() {
            await generateNewRack();
        }
        
        // Funci√≥n removida - ya no necesitamos mostrar validaci√≥n manual
        
        // Funci√≥n removida - el rechazo de atril ahora es autom√°tico
        
        // Funci√≥n removida - la aceptaci√≥n de atril es autom√°tica
        
        async function updateTilesRemaining() {
            if (!currentTournamentId) return;
            
            const result = await apiCall('GET', `/tournament/${currentTournamentId}`);
            if (result.success && result.data) {
                document.getElementById('tilesRemaining').textContent = 
                    `Fichas en bolsa: ${result.data.tiles_remaining}`;
            }
        }
        
        async function startTimer() {
            // Primero, notificar al servidor que se inici√≥ el timer
            const result = await apiCall('PUT', `/tournament/${currentTournamentId}/round/${currentRound.number}/start_timer`);
            if (!result.success) {
                alert('Error al iniciar timer: ' + result.error);
                return;
            }
            
            timeRemaining = 180;
            
            timerInterval = setInterval(() => {
                timeRemaining--;
                const minutes = Math.floor(timeRemaining / 60);
                const seconds = timeRemaining % 60;
                document.getElementById('timerDisplay').textContent = 
                    `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                if (timeRemaining <= 0) {
                    clearInterval(timerInterval);
                    document.getElementById('timerDisplay').textContent = '0:00';
                    // Al terminar el tiempo, revelar y colocar autom√°ticamente
                    revealAndPlaceOptimalPlay();
                }
            }, 1000);
        }
        
        async function placeOptimalPlay() {
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            
            if (!currentTournamentId || !currentRound) return;
            
            // Actualizar el rack visual inmediatamente
            if (currentRound.optimal_play) {
                updateRackAfterPlay(currentRound.rack, currentRound.optimal_play.tiles_used);
            }
            
            // Colocar la jugada √≥ptima y actualizar el Master
            const result = await apiCall('PUT', 
                `/tournament/${currentTournamentId}/round/${currentRound.number}/place_optimal`);
            
            if (result.success) {
                // Reiniciar controles
                // Timer ya est√° siempre visible en la parte superior
                document.getElementById('startTimerBtn').style.display = 'inline-block';
                document.getElementById('placePlayBtn').style.display = 'none';
                document.getElementById('revealPlayBtn').style.display = 'none';
                document.getElementById('timerDisplay').textContent = '3:00';
                document.getElementById('optimalPlay').innerHTML = '';
                optimalPlayData = null;
                
                // Actualizar tabla del Master y fichas
                updateMasterPlays();
                updateBagTiles();
                updateRoundButton();
            }
        }
        
        // Funci√≥n para actualizar el bot√≥n universal
        function updateUniversalButton(state) {
            currentButtonState = state;
            const btn = document.getElementById('universalBtn');
            
            switch(state) {
                case BUTTON_STATES.GENERATE_RACK:
                    // Calcular n√∫mero de ronda basado en el torneo actual
                    let roundNum = 1;
                    if (currentTournament && currentTournament.rounds) {
                        roundNum = currentTournament.rounds.length + 1;
                    } else if (currentRound) {
                        roundNum = currentRound.number + 1;
                    }
                    btn.textContent = `üé≤ Generar Atril de la Ronda ${roundNum}`;
                    btn.style.background = '#27ae60';
                    btn.disabled = false;
                    break;
                    
                case BUTTON_STATES.INVALID_RACK:
                    btn.textContent = 'üîÑ Generar Nuevo Atril';
                    btn.style.background = '#e74c3c';
                    btn.disabled = false;
                    break;
                    
                case BUTTON_STATES.START_ROUND:
                    btn.textContent = '‚ñ∂Ô∏è Iniciar Ronda';
                    btn.style.background = '#3498db';
                    btn.disabled = false;
                    break;
                    
                case BUTTON_STATES.REVEAL_PLAY:
                    btn.textContent = 'üëÅÔ∏è Revelar Jugada del Master';
                    btn.style.background = '#e67e22';
                    btn.disabled = false;
                    break;
                    
                case BUTTON_STATES.GAME_OVER:
                    btn.textContent = 'üèÅ Partida Terminada';
                    btn.style.background = '#95a5a6';
                    btn.disabled = true;
                    break;
            }
        }
        
        // Funci√≥n principal del bot√≥n universal
        async function handleUniversalAction() {
            switch(currentButtonState) {
                case BUTTON_STATES.GENERATE_RACK:
                case BUTTON_STATES.INVALID_RACK:
                    await generateNewRack();
                    break;
                    
                case BUTTON_STATES.START_ROUND:
                    await startRoundWithTimer();
                    break;
                    
                case BUTTON_STATES.REVEAL_PLAY:
                    await revealAndPlaceOptimalPlay();
                    break;
            }
        }

        function displayRack(rack) {
            const rackEl = document.getElementById('rack');
            const shuffleBtn = document.getElementById('shuffleBtn');
            rackEl.style.display = 'flex';
            rackEl.style.justifyContent = 'center'; // Restaurar centrado para rack completo
            rackEl.innerHTML = '';
            
            // Mostrar bot√≥n de shuffle
            shuffleBtn.style.display = 'block';
            
            // Guardar el rack actual para shuffle
            window.currentRackTiles = rack;
            
            // Procesar el rack para manejar d√≠grafos
            let i = 0;
            while (i < rack.length) {
                let letter = rack[i];
                let originalLetter = rack[i]; // Guardar la letra original
                
                // Detectar d√≠grafos entre corchetes
                if (letter === '[') {
                    let j = i + 1;
                    while (j < rack.length && rack[j] !== ']') {
                        j++;
                    }
                    if (j < rack.length) {
                        // Guardar el d√≠grafo completo con corchetes
                        originalLetter = rack.substring(i, j + 1);
                        // Extraer el d√≠grafo sin corchetes para mostrar
                        letter = rack.substring(i + 1, j).toUpperCase();
                        i = j; // Saltar al ]
                    }
                }
                
                const tile = document.createElement('div');
                tile.className = 'rack-tile';
                tile.textContent = letter;
                tile.draggable = true;
                tile.dataset.tileIndex = rackEl.children.length;
                tile.dataset.tile = originalLetter;
                
                // Detectar d√≠grafos
                if (letter.length > 1) {
                    tile.classList.add('digraph');
                }
                
                // Agregar valor de la ficha
                const value = tileValues[letter] || 0;
                if (value > 0) {
                    const valueSpan = document.createElement('span');
                    valueSpan.className = 'tile-value';
                    valueSpan.textContent = value;
                    tile.appendChild(valueSpan);
                }
                
                // Event listeners para drag and drop
                tile.addEventListener('dragstart', handleDragStart);
                tile.addEventListener('dragend', handleDragEnd);
                tile.addEventListener('dragover', handleDragOver);
                tile.addEventListener('drop', handleDrop);
                tile.addEventListener('dragenter', handleDragEnter);
                tile.addEventListener('dragleave', handleDragLeave);
                
                rackEl.appendChild(tile);
                i++;
            }
        }
        
        // Variables para drag and drop
        let draggedTile = null;
        let draggedIndex = null;
        
        // Funciones para manejar drag and drop
        function handleDragStart(e) {
            draggedTile = this;
            draggedIndex = parseInt(this.dataset.tileIndex);
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.innerHTML);
        }
        
        function handleDragEnd(e) {
            this.classList.remove('dragging');
            
            // Remover clases de todos los tiles
            const tiles = document.querySelectorAll('.rack-tile');
            tiles.forEach(tile => {
                tile.classList.remove('drag-over');
            });
        }
        
        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            return false;
        }
        
        function handleDragEnter(e) {
            if (this !== draggedTile) {
                this.classList.add('drag-over');
            }
        }
        
        function handleDragLeave(e) {
            this.classList.remove('drag-over');
        }
        
        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            
            if (draggedTile !== this) {
                const targetIndex = parseInt(this.dataset.tileIndex);
                const rackEl = document.getElementById('rack');
                const tiles = Array.from(rackEl.querySelectorAll('.rack-tile'));
                
                // Reorganizar las fichas
                const draggedTileData = tiles[draggedIndex];
                tiles.splice(draggedIndex, 1);
                tiles.splice(targetIndex, 0, draggedTileData);
                
                // Reconstruir el rack
                const newRackArray = [];
                tiles.forEach(tile => {
                    newRackArray.push(tile.dataset.tile);
                });
                
                // Actualizar el rack
                const newRack = newRackArray.join('');
                window.currentRackTiles = newRack;
                displayRack(newRack);
            }
            
            return false;
        }
        
        // Funci√≥n para revolver las fichas del atril
        function shuffleRack() {
            if (!window.currentRackTiles) return;
            
            const rackEl = document.getElementById('rack');
            
            // Convertir el rack a array de fichas
            const tiles = [];
            let i = 0;
            const rack = window.currentRackTiles;
            
            while (i < rack.length) {
                let letter = rack[i];
                
                if (letter === '[') {
                    let j = i + 1;
                    while (j < rack.length && rack[j] !== ']') {
                        j++;
                    }
                    if (j < rack.length) {
                        letter = rack.substring(i, j + 1);
                        i = j;
                    }
                }
                
                tiles.push(letter);
                i++;
            }
            
            // Revolver las fichas usando Fisher-Yates
            for (let i = tiles.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
            }
            
            // Reconstruir el rack string
            const shuffledRack = tiles.join('');
            window.currentRackTiles = shuffledRack;
            
            // Animar la transici√≥n
            const currentTiles = rackEl.querySelectorAll('.rack-tile');
            currentTiles.forEach((tile, index) => {
                tile.style.transition = 'transform 0.3s ease-out';
                tile.style.transform = 'translateY(-20px) rotateZ(' + (Math.random() * 20 - 10) + 'deg)';
                tile.style.opacity = '0.5';
            });
            
            setTimeout(() => {
                displayRack(shuffledRack);
            }, 300);
        }
        
        // Actualizar el rack visual mostrando solo las fichas restantes
        function updateRackAfterPlay(originalRack, tilesUsed) {
            console.log('updateRackAfterPlay called');
            console.log('Original rack:', originalRack);
            console.log('Tiles used:', tilesUsed);
            
            const rackEl = document.getElementById('rack');
            
            // Convertir el rack a array de fichas
            const rackTiles = [];
            let i = 0;
            while (i < originalRack.length) {
                let letter = originalRack[i];
                
                if (letter === '[') {
                    let j = i + 1;
                    while (j < originalRack.length && originalRack[j] !== ']') {
                        j++;
                    }
                    if (j < originalRack.length) {
                        // Incluir los corchetes para la comparaci√≥n
                        letter = originalRack.substring(i, j + 1);
                        i = j;
                    }
                }
                
                rackTiles.push(letter);
                i++;
            }
            
            console.log('Parsed rack tiles:', rackTiles);
            
            // Crear copia del rack para remover fichas usadas
            const remainingTiles = [...rackTiles];
            
            // Remover las fichas usadas
            for (const usedTile of tilesUsed) {
                if (usedTile && usedTile !== '') {
                    console.log('Removing tile:', usedTile);
                    let index = remainingTiles.findIndex(tile => tile === usedTile);
                    
                    // Si no encontramos la ficha exacta, podr√≠a ser un comod√≠n usado como esa letra
                    if (index === -1 && remainingTiles.includes('?')) {
                        // Verificar si la letra usada no est√° en el rack original
                        const originalHasThisTile = rackTiles.filter(t => t === usedTile).length > 0;
                        const alreadyRemovedCount = rackTiles.filter(t => t === usedTile).length - 
                                                   remainingTiles.filter(t => t === usedTile).length;
                        
                        // Si ya removimos todas las instancias de esta letra que estaban en el rack original,
                        // entonces debe ser un comod√≠n
                        if (!originalHasThisTile || alreadyRemovedCount >= rackTiles.filter(t => t === usedTile).length) {
                            index = remainingTiles.findIndex(tile => tile === '?');
                            if (index !== -1) {
                                console.log('Using blank tile (?) for:', usedTile);
                            }
                        }
                    }
                    
                    if (index !== -1) {
                        remainingTiles.splice(index, 1);
                        console.log('Removed tile at index:', index);
                    } else {
                        console.log('Tile not found in remaining tiles:', usedTile);
                    }
                }
            }
            
            console.log('Remaining tiles after removal:', remainingTiles);
            
            // Animar las fichas actuales saliendo
            const currentTiles = rackEl.querySelectorAll('.rack-tile');
            currentTiles.forEach((tile, index) => {
                tile.classList.add('slide-out');
            });
            
            // Esperar a que termine la animaci√≥n de salida
            setTimeout(() => {
                rackEl.innerHTML = '';
                
                if (remainingTiles.length === 0) {
                    // Rack vac√≠o
                    const emptyMsg = document.createElement('div');
                    emptyMsg.style.color = '#999';
                    emptyMsg.style.fontSize = '14px';
                    emptyMsg.style.textAlign = 'center';
                    emptyMsg.style.width = '100%';
                    emptyMsg.textContent = '(Rack vac√≠o - se usaron todas las fichas)';
                    rackEl.appendChild(emptyMsg);
                } else {
                    // Cambiar justificaci√≥n del rack para alinear a la izquierda
                    rackEl.style.justifyContent = 'flex-start';
                    
                    // Mostrar fichas restantes con animaci√≥n de entrada
                    remainingTiles.forEach((tile, index) => {
                        const tileEl = document.createElement('div');
                        tileEl.className = 'rack-tile slide-in';
                        // Quitar corchetes para display
                        const cleanTile = tile.replace(/[\[\]]/g, '');
                        tileEl.textContent = cleanTile;
                        
                        // Detectar d√≠grafos
                        if (cleanTile.length > 1) {
                            tileEl.classList.add('digraph');
                        }
                        
                        // Agregar valor de la ficha
                        const value = tileValues[cleanTile] || 0;
                        if (value > 0) {
                            const valueSpan = document.createElement('span');
                            valueSpan.className = 'tile-value';
                            valueSpan.textContent = value;
                            tileEl.appendChild(valueSpan);
                        }
                        
                        // Retrasar la animaci√≥n de entrada para cada ficha
                        tileEl.style.animationDelay = `${index * 0.1}s`;
                        
                        rackEl.appendChild(tileEl);
                    });
                }
            }, 500);
        }

        function updateBoard(boardState) {
            // Limpiar highlights anteriores
            document.querySelectorAll('.cell').forEach(cell => {
                cell.classList.remove('filled', 'highlight', 'blank');
            });
            
            boardState.tiles.forEach((tile, index) => {
                const cell = document.getElementById(`cell-${index}`);
                if (cell && tile) {
                    // Detectar si es un comod√≠n (letra min√∫scula)
                    const isBlank = tile.length === 1 && tile === tile.toLowerCase() && tile !== tile.toUpperCase();
                    
                    // Limpiar d√≠grafos
                    const cleanTile = tile.replace(/\[([^\]]+)\]/g, '$1').toUpperCase();
                    cell.textContent = cleanTile;
                    cell.classList.add('filled');
                    
                    // Detectar d√≠grafos
                    if (cleanTile.length > 1) {
                        cell.classList.add('digraph');
                    }
                    
                    // Agregar valor de la ficha
                    const value = tileValues[cleanTile] || 0;
                    if (value > 0 && !isBlank) {
                        const valueSpan = document.createElement('span');
                        valueSpan.className = 'tile-value';
                        valueSpan.textContent = value;
                        cell.appendChild(valueSpan);
                    }
                    
                    if (isBlank) {
                        cell.classList.add('blank');
                    }
                }
            });
        }

        async function getOptimalPlay(showImmediately = true) {
            if (!currentTournamentId || !currentRound) return;
            
            const result = await apiCall('GET', 
                `/tournament/${currentTournamentId}/round/${currentRound.number}/optimal`);
            
            if (result.success && result.data) {
                optimalPlayData = result.data;
                console.log('Optimal play data received:', optimalPlayData);
                
                if (showImmediately) {
                    displayOptimalPlay();
                }
            }
        }
        
        function displayOptimalPlay() {
            if (!optimalPlayData) return;
            
            const play = optimalPlayData;
            // Limpiar d√≠grafos pero preservar may√∫sculas/min√∫sculas para comodines
            let displayWord = '';
            for (let i = 0; i < play.word.length; i++) {
                if (play.word[i] === '[' && play.word.indexOf(']', i) !== -1) {
                    // Handle digraph - always uppercase
                    const end = play.word.indexOf(']', i);
                    const digraph = play.word.substring(i + 1, end);
                    displayWord += digraph.toUpperCase();
                    i = end;
                } else {
                    // Preserve case for blanks
                    displayWord += play.word[i];
                }
            }
            
            document.getElementById('optimalPlay').innerHTML = `
                <div class="optimal-play">
                    <h4>üèÜ Jugada √ìptima</h4>
                    <strong>${displayWord}</strong> - ${play.score} puntos<br>
                    <small>
                        ${getCoordinate(play.position.row, play.position.col, play.position.down)} 
                        ${play.position.down ? '‚Üì' : '‚Üí'}
                    </small>
                </div>
            `;
            
            // Animar la jugada √≥ptima
            highlightPlay(play);
        }
        
        async function revealAndPlaceOptimalPlay() {
            if (!currentTournamentId || !currentRound) return;
            
            if (timerInterval) {
                clearInterval(timerInterval);
                document.getElementById('timerDisplay').textContent = '3:00';
            }
            
            // Primero revelar la jugada √≥ptima
            await apiCall('PUT', `/tournament/${currentTournamentId}/round/${currentRound.number}/reveal_optimal`);
            
            // Mostrar la jugada √≥ptima
            displayOptimalPlay();
            
            // Esperar un momento para que el usuario vea la jugada
            setTimeout(async () => {
                // Actualizar el rack visual inmediatamente usando optimalPlayData
                if (optimalPlayData && optimalPlayData.tiles_used) {
                    updateRackAfterPlay(currentRound.rack, optimalPlayData.tiles_used);
                }
                
                // Luego colocarla
                const result = await apiCall('PUT', 
                    `/tournament/${currentTournamentId}/round/${currentRound.number}/place_optimal`);
                
                if (result.success) {
                    // Limpiar jugada √≥ptima mostrada
                    document.getElementById('optimalPlay').innerHTML = '';
                    optimalPlayData = null;
                    
                    // Actualizar tabla del Master y fichas
                    updateMasterPlays();
                    updateBagTiles();
                    
                    // Verificar si el juego termin√≥
                    const endResult = await checkGameEnd();
                    if (!endResult || !endResult.game_ended) {
                        // Si no termin√≥, cambiar bot√≥n para siguiente ronda
                        updateUniversalButton(BUTTON_STATES.GENERATE_RACK);
                    } else {
                        // Si termin√≥, cambiar a estado final
                        updateUniversalButton(BUTTON_STATES.GAME_OVER);
                        showFinalLeaderboard(endResult.reason);
                    }
                }
            }, 2000); // Esperar 2 segundos para que se vea la jugada
        }

        function getCoordinate(row, col, isDown) {
            // En Scrabble, el orden de coordenadas indica direcci√≥n:
            // Horizontal (‚Üí): Fila + Columna (ej: H8)
            // Vertical (‚Üì): Columna + Fila (ej: 8H)
            const letters = 'ABCDEFGHIJKLMNO';
            if (isDown) {
                // Vertical: columna (n√∫mero) + fila (letra)
                return `${col + 1}${letters[row]}`;
            } else {
                // Horizontal: fila (letra) + columna (n√∫mero)
                return `${letters[row]}${col + 1}`;
            }
        }

        function highlightPlay(play) {
            console.log('highlightPlay - word:', play.word, 'tiles_used:', play.tiles_used);
            const start = play.position.row * 15 + play.position.col;
            
            // Remover contorno anterior si existe
            const existingOutline = document.querySelector('.word-outline');
            if (existingOutline) {
                existingOutline.remove();
            }
            
            // Build the word without anchors to check for blanks
            let wordWithoutAnchors = '';
            let wordIndex = 0;
            
            // First pass: build the word without anchors
            for (let i = 0; i < play.word.length; i++) {
                if (play.word[i] === '(' && play.word.indexOf(')', i) !== -1) {
                    // Skip anchor
                    i = play.word.indexOf(')', i);
                } else if (play.word[i] === '[' && play.word.indexOf(']', i) !== -1) {
                    // Handle digraph
                    const end = play.word.indexOf(']', i);
                    wordWithoutAnchors += play.word.substring(i, end + 1);
                    i = end;
                } else {
                    wordWithoutAnchors += play.word[i];
                }
            }
            
            console.log('Word without anchors:', wordWithoutAnchors);
            
            // Now highlight tiles
            wordIndex = 0;
            play.tiles_used.forEach((tile, index) => {
                if (tile) {
                    // Check if this tile corresponds to a lowercase letter in the word
                    let isBlank = false;
                    
                    // Find the corresponding character in wordWithoutAnchors
                    if (wordIndex < wordWithoutAnchors.length) {
                        const char = wordWithoutAnchors[wordIndex];
                        // Check if it's a lowercase letter (blank)
                        isBlank = char === char.toLowerCase() && char !== char.toUpperCase();
                        
                        // Handle digraphs
                        if (wordWithoutAnchors[wordIndex] === '[') {
                            const endBracket = wordWithoutAnchors.indexOf(']', wordIndex);
                            wordIndex = endBracket + 1;
                        } else {
                            wordIndex++;
                        }
                    }
                    
                    console.log('Tile:', tile, 'isBlank:', isBlank);
                    
                    // Limpiar d√≠grafos
                    const cleanTile = tile.replace(/\[([^\]]+)\]/g, '$1').toUpperCase();
                    
                    const cellIndex = play.position.down ? 
                        start + (index * 15) : 
                        start + index;
                    const cell = document.getElementById(`cell-${cellIndex}`);
                    if (cell) {
                        cell.classList.add('highlight');
                        setTimeout(() => {
                            cell.textContent = cleanTile;
                            cell.classList.add('filled');
                            
                            // Detectar d√≠grafos
                            if (cleanTile.length > 1) {
                                cell.classList.add('digraph');
                            }
                            
                            // Agregar valor de la ficha
                            const value = tileValues[cleanTile] || 0;
                            if (value > 0 && !isBlank) {
                                const valueSpan = document.createElement('span');
                                valueSpan.className = 'tile-value';
                                valueSpan.textContent = value;
                                cell.appendChild(valueSpan);
                            }
                            
                            if (isBlank) {
                                cell.classList.add('blank');
                                console.log('Added blank class to cell', cellIndex);
                            }
                        }, 300);
                    }
                }
            });
            
            // Crear contorno naranja alrededor de toda la palabra
            setTimeout(() => {
                const highlightedCells = document.querySelectorAll('.cell.highlight');
                if (highlightedCells.length > 0) {
                    const board = document.getElementById('board');
                    const boardRect = board.getBoundingClientRect();
                    
                    // Encontrar los l√≠mites de la palabra
                    let minX = Infinity, minY = Infinity;
                    let maxX = -Infinity, maxY = -Infinity;
                    
                    highlightedCells.forEach(cell => {
                        const rect = cell.getBoundingClientRect();
                        minX = Math.min(minX, rect.left);
                        minY = Math.min(minY, rect.top);
                        maxX = Math.max(maxX, rect.right);
                        maxY = Math.max(maxY, rect.bottom);
                    });
                    
                    // Crear el contorno pegado al borde de las fichas
                    const outline = document.createElement('div');
                    outline.className = 'word-outline';
                    outline.style.left = (minX - boardRect.left - 2) + 'px';
                    outline.style.top = (minY - boardRect.top - 2) + 'px';
                    outline.style.width = (maxX - minX + 4) + 'px';
                    outline.style.height = (maxY - minY + 4) + 'px';
                    
                    board.appendChild(outline);
                }
            }, 350); // Esperar un poco m√°s que la animaci√≥n de las fichas
        }

        async function updateLeaderboard() {
            if (!currentTournamentId) return;
            
            const result = await apiCall('GET', `/tournament/${currentTournamentId}/leaderboard`);
            
            if (result.success && result.data) {
                const leaderboard = document.getElementById('leaderboard');
                leaderboard.innerHTML = `
                    <table class="leaderboard">
                        <thead>
                            <tr>
                                <th>Pos</th>
                                <th>Jugador</th>
                                <th>Puntos</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${result.data.map((player, index) => `
                                <tr>
                                    <td>${index + 1}</td>
                                    <td>${player.name}</td>
                                    <td>${player.total_score}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
            }
        }

        async function updateBagTiles() {
            if (!currentTournamentId) {
                console.log('No tournament ID for bag tiles');
                return;
            }
            
            console.log('Fetching bag tiles for tournament:', currentTournamentId);
            const result = await apiCall('GET', `/tournament/${currentTournamentId}/bag_tiles`);
            
            console.log('Bag tiles result:', result);
            
            if (result.success && result.data) {
                const bagTilesEl = document.getElementById('bagTiles');
                bagTilesEl.innerHTML = '';
                
                console.log('Tracking all', result.data.length, 'tiles in game (used and available)');
                
                // Agrupar fichas por letra
                const tileGroups = {};
                result.data.forEach(([tile, used]) => {
                    // Limpiar d√≠grafos de corchetes
                    if (tile.startsWith('[') && tile.endsWith(']')) {
                        tile = tile.substring(1, tile.length - 1).toUpperCase();
                    }
                    
                    if (!tileGroups[tile]) {
                        tileGroups[tile] = { total: 0, used: 0 };
                    }
                    tileGroups[tile].total++;
                    if (used) tileGroups[tile].used++;
                });
                
                console.log('Tile groups:', tileGroups);
                
                // Mostrar fichas ordenadas - Spanish alphabet order
                const spanishOrder = ['?', 'A', 'B', 'C', 'CH', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'L', 'LL', 'M', 'N', '√ë', 'O', 'P', 'Q', 'R', 'RR', 'S', 'T', 'U', 'V', 'X', 'Y', 'Z'];
                const sortedTiles = Object.keys(tileGroups).sort((a, b) => {
                    const cleanA = a.replace(/\[|\]/g, '');
                    const cleanB = b.replace(/\[|\]/g, '');
                    return spanishOrder.indexOf(cleanA) - spanishOrder.indexOf(cleanB);
                });
                sortedTiles.forEach(tile => {
                    const group = tileGroups[tile];
                    // Primero las no usadas
                    for (let i = 0; i < group.total - group.used; i++) {
                        const tileEl = document.createElement('div');
                        tileEl.className = 'bag-tile';
                        // Remove brackets for display
                        tileEl.textContent = tile.replace(/\[([^\]]+)\]/g, '$1');
                        bagTilesEl.appendChild(tileEl);
                    }
                    // Luego las usadas (atenuadas)
                    for (let i = 0; i < group.used; i++) {
                        const tileEl = document.createElement('div');
                        tileEl.className = 'bag-tile used';
                        // Remove brackets for display
                        tileEl.textContent = tile.replace(/\[([^\]]+)\]/g, '$1');
                        bagTilesEl.appendChild(tileEl);
                    }
                });
            } else {
                console.error('Failed to get bag tiles:', result.error);
            }
        }
        
        async function updateMasterPlays() {
            if (!currentTournamentId) return;
            
            const result = await apiCall('GET', `/tournament/${currentTournamentId}`);
            
            if (result.success && result.data) {
                const masterPlays = result.data.master_plays || [];
                const tbody = document.querySelector('#masterPlays tbody');
                tbody.innerHTML = '';
                
                masterPlays.forEach(play => {
                    // Limpiar d√≠grafos en la palabra
                    const cleanWord = play.word.replace(/\[([^\]]+)\]/g, '$1').toUpperCase();
                    
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${play.round_number}</td>
                        <td>${getCoordinate(play.position.row, play.position.col, play.position.down)}${play.position.down ? '‚Üì' : '‚Üí'}</td>
                        <td><strong>${cleanWord}</strong></td>
                        <td>${play.score}</td>
                        <td><strong>${play.cumulative_score}</strong></td>
                    `;
                    tbody.appendChild(row);
                });
            }
        }
        
        async function updateRoundButton() {
            if (!currentTournamentId) return;
            
            const result = await apiCall('GET', `/tournament/${currentTournamentId}`);
            if (result.success && result.data) {
                const nextRound = result.data.rounds.length + 1;
                document.getElementById('newRoundBtn').textContent = `Generar Atril de la Ronda ${nextRound}`;
            }
        }
        
        function countTilesInRack(rack) {
            // Contar fichas considerando d√≠grafos
            let count = 0;
            let i = 0;
            while (i < rack.length) {
                if (i < rack.length - 1) {
                    const digraph = rack.substring(i, i + 2);
                    if (digraph === 'CH' || digraph === 'LL' || digraph === 'RR') {
                        count++;
                        i += 2;
                        continue;
                    }
                }
                count++;
                i++;
            }
            return count;
        }
        
        function validateManualRack() {
            const input = document.getElementById('manualRack').value.trim().toUpperCase();
            const validationMsg = document.getElementById('rackValidationMessage');
            const useBtn = document.getElementById('useManualBtn');
            
            if (!input) {
                validationMsg.innerHTML = '<span style="color: #666;">Escriba las letras. Los d√≠grafos CH, LL, RR cuentan como 1 ficha.</span>';
                useBtn.disabled = false;
                return;
            }
            
            const tileCount = countTilesInRack(input);
            
            if (tileCount < 7) {
                validationMsg.innerHTML = `<span style="color: #f39c12;">Tiene ${tileCount} fichas. Necesita ${7 - tileCount} m√°s.</span>`;
                useBtn.disabled = true;
            } else if (tileCount > 7) {
                validationMsg.innerHTML = `<span style="color: #e74c3c;">Tiene ${tileCount} fichas. Quite ${tileCount - 7}.</span>`;
                useBtn.disabled = true;
            } else {
                // Mostrar las fichas que se usar√°n
                let fichas = [];
                let i = 0;
                while (i < input.length) {
                    if (i < input.length - 1) {
                        const digraph = input.substring(i, i + 2);
                        if (digraph === 'CH' || digraph === 'LL' || digraph === 'RR') {
                            fichas.push(digraph);
                            i += 2;
                            continue;
                        }
                    }
                    fichas.push(input[i]);
                    i++;
                }
                validationMsg.innerHTML = `<span style="color: #27ae60;">‚úì 7 fichas: ${fichas.join(' ')}</span>`;
                useBtn.disabled = false;
            }
        }
        
        async function useManualRack() {
            const manualRackInput = document.getElementById('manualRack').value.trim().toUpperCase();
            
            if (!manualRackInput) {
                alert('Por favor ingrese las fichas del atril');
                return;
            }
            
            if (!currentTournamentId) {
                alert('Primero debe crear un torneo');
                return;
            }
            
            // Procesar el input para manejar d√≠grafos
            let processedRack = manualRackInput
                .replace(/CH/g, '[CH]')
                .replace(/LL/g, '[LL]')
                .replace(/RR/g, '[RR]');
            
            // Validar longitud usando la misma funci√≥n
            const tileCount = countTilesInRack(manualRackInput);
            
            if (tileCount !== 7) {
                // Esto no deber√≠a pasar si el bot√≥n est√° deshabilitado correctamente
                alert(`El atril debe tener exactamente 7 fichas (tiene ${tileCount})`);
                return;
            }
            
            // Llamar al servidor con el atril manual
            const result = await apiCall('POST', `/tournament/${currentTournamentId}/round/start_manual`, {
                rack: processedRack
            });
            
            if (result.success && result.data) {
                currentRound = result.data;
                
                // Mostrar info de la ronda
                document.getElementById('roundInfo').innerHTML = `
                    <div class="info-section">
                        <h3>Ronda ${result.data.number}</h3>
                        <p style="color: #3498db;">Atril ingresado manualmente</p>
                    </div>
                `;
                
                // Mostrar atril
                displayRack(result.data.rack);
                
                // Actualizar tablero
                updateBoard(result.data.board_state);
                
                // Mostrar validaci√≥n
                // La validaci√≥n es autom√°tica y no necesita mostrarse
                
                // Actualizar fichas restantes
                updateTilesRemaining();
                updateBagTiles();
                
                // Limpiar el input
                document.getElementById('manualRack').value = '';
            } else {
                alert('Error: ' + (result.error || 'No se pudo usar el atril manual'));
            }
        }
        
        async function undoLastRound() {
            if (!currentTournamentId) return;
            
            if (!confirm('¬øEst√°s seguro de que quieres deshacer la √∫ltima ronda completada?')) {
                return;
            }
            
            const result = await apiCall('PUT', `/tournament/${currentTournamentId}/undo`);
            
            if (result.success) {
                // Limpiar estado actual
                currentRound = null;
                optimalPlayData = null;
                document.getElementById('optimalPlay').innerHTML = '';
                document.getElementById('roundInfo').innerHTML = '';
                document.getElementById('rack').style.display = 'none';
                // Elemento de validaci√≥n removido
                // Timer ya est√° siempre visible en la parte superior
                
                // Recargar el estado del torneo
                const tournamentResult = await apiCall('GET', `/tournament/${currentTournamentId}`);
                if (tournamentResult.success && tournamentResult.data) {
                    // Reconstruir el tablero basado en las jugadas maestras restantes
                    initializeBoard();
                    
                    // Aplicar todas las jugadas maestras al tablero
                    for (const play of tournamentResult.data.master_plays) {
                        applyPlayToBoard(play);
                    }
                    
                    // Actualizar UI
                    updateMasterPlays();
                    updateBagTiles();
                    updateRoundButton();
                    
                    alert('Se deshizo la √∫ltima ronda exitosamente');
                }
            } else {
                alert('Error: ' + (result.error || 'No se pudo deshacer la ronda'));
            }
        }
        
        function applyPlayToBoard(play) {
            const start = play.position.row * 15 + play.position.col;
            
            // Parse the word to get individual tiles
            let tiles = [];
            let i = 0;
            while (i < play.word.length) {
                if (play.word[i] === '(' && play.word.indexOf(')', i) !== -1) {
                    // Skip anchor tiles
                    i = play.word.indexOf(')', i) + 1;
                } else if (play.word[i] === '[' && play.word.indexOf(']', i) !== -1) {
                    // Handle digraphs
                    const end = play.word.indexOf(']', i);
                    tiles.push(play.word.substring(i, end + 1));
                    i = end + 1;
                } else {
                    tiles.push(play.word[i]);
                    i++;
                }
            }
            
            // Apply tiles to board
            let tileIndex = 0;
            for (let j = 0; j < tiles.length; j++) {
                const tile = tiles[j];
                if (tile && tile !== '(' && tile !== ')') {
                    const cellIndex = play.position.down ? 
                        start + (tileIndex * 15) : 
                        start + tileIndex;
                    
                    const cell = document.getElementById(`cell-${cellIndex}`);
                    if (cell) {
                        const isBlank = tile === tile.toLowerCase() && tile !== tile.toUpperCase();
                        const cleanTile = tile.replace(/\[([^\]]+)\]/g, '$1').toUpperCase();
                        
                        cell.textContent = cleanTile;
                        cell.classList.add('filled');
                        
                        // Detectar d√≠grafos
                        if (cleanTile.length > 1) {
                            cell.classList.add('digraph');
                        }
                        
                        // Agregar valor de la ficha
                        const value = tileValues[cleanTile] || 0;
                        if (value > 0 && !isBlank) {
                            const valueSpan = document.createElement('span');
                            valueSpan.className = 'tile-value';
                            valueSpan.textContent = value;
                            cell.appendChild(valueSpan);
                        }
                        
                        if (isBlank) {
                            cell.classList.add('blank');
                        }
                    }
                    tileIndex++;
                }
            }
        }
        
        // Toggle bonus tags visibility
        function toggleBonusTags() {
            const toggle = document.getElementById('bonusToggle');
            toggle.classList.toggle('active');
            
            const labels = document.querySelectorAll('.premium-label');
            
            if (toggle.classList.contains('active')) {
                labels.forEach(label => label.classList.remove('hidden'));
            } else {
                labels.forEach(label => label.classList.add('hidden'));
            }
        }

        // Inicializar tablero vac√≠o al cargar
        window.onload = () => {
            initializeBoard();
        };
        
        async function checkGameEnd() {
            if (!currentTournamentId) return null;
            
            const result = await apiCall('GET', `/tournament/${currentTournamentId}/check_end`);
            if (result.success && result.data) {
                return result.data;
            }
            return null;
        }
        
        async function showFinalLeaderboard(reason) {
            // Obtener leaderboard final con Master incluido
            const tournamentResult = await apiCall('GET', `/tournament/${currentTournamentId}`);
            if (!tournamentResult.success) return;
            
            const tournament = tournamentResult.data;
            const leaderboardResult = await apiCall('GET', `/tournament/${currentTournamentId}/leaderboard`);
            if (!leaderboardResult.success) return;
            
            const players = leaderboardResult.data;
            
            // Calcular puntuaci√≥n del Master
            const masterScore = tournament.master_plays.reduce((sum, play) => sum + play.score, 0);
            
            // Agregar Master al leaderboard
            const allPlayers = [...players, { name: 'Master', total_score: masterScore }];
            allPlayers.sort((a, b) => b.total_score - a.total_score);
            
            // Crear y mostrar modal
            const modal = document.getElementById('finalLeaderboardModal');
            const tbody = document.getElementById('finalLeaderboardBody');
            const reasonEl = document.getElementById('gameOverReason');
            
            reasonEl.textContent = reason || 'Juego terminado';
            
            tbody.innerHTML = allPlayers.map((player, index) => `
                <tr>
                    <td>${index + 1}</td>
                    <td>${player.name}</td>
                    <td>${player.total_score}</td>
                </tr>
            `).join('');
            
            modal.style.display = 'block';
            
            // Guardar estado del juego
            document.getElementById('newRoundBtn').disabled = true;
            document.getElementById('newRoundBtn').textContent = 'Juego Terminado';
        }
        
        function closeFinalLeaderboard() {
            document.getElementById('finalLeaderboardModal').style.display = 'none';
        }
        
        async function checkAndShowFinalLeaderboard() {
            // Verificar primero si el juego termin√≥
            const result = await apiCall('GET', `/tournament/${currentTournamentId}/check_end`);
            if (result.success && result.data) {
                showFinalLeaderboard(result.data.reason || 'Tabla de posiciones actual');
            }
        }
        
        // Funci√≥n para mostrar notificaci√≥n de atril inv√°lido
        function showInvalidRackNotification(round) {
            const tiles = round.rack.split('');
            const vowels = tiles.filter(t => 'AEIOU'.includes(t)).length;
            const consonants = tiles.filter(t => t !== '?' && !'AEIOU'.includes(t)).length;
            const blanks = tiles.filter(t => t === '?').length;
            
            let reason = '';
            if (round.number <= 15) {
                reason = `Ronda ${round.number}: Se requieren m√≠nimo 2 vocales y 2 consonantes.`;
            } else {
                reason = `Ronda ${round.number}: Se requiere al menos 1 vocal o 1 consonante.`;
            }
            
            // Crear modal de notificaci√≥n
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: white;
                padding: 20px;
                border-radius: 10px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                z-index: 1000;
                max-width: 400px;
                text-align: center;
            `;
            
            modal.innerHTML = `
                <h3 style="color: #e74c3c; margin-bottom: 15px;">‚ö†Ô∏è Atril Inv√°lido</h3>
                <p style="margin-bottom: 10px;"><strong>Atril:</strong> ${round.rack}</p>
                <p style="margin-bottom: 10px;">Vocales: ${vowels} | Consonantes: ${consonants} | Comodines: ${blanks}</p>
                <p style="color: #666; margin-bottom: 20px;">${reason}</p>
                <button onclick="closeInvalidRackModal()" style="background: #3498db; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer;">
                    Entendido
                </button>
            `;
            
            // Crear overlay
            const overlay = document.createElement('div');
            overlay.id = 'invalidRackOverlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                z-index: 999;
            `;
            
            document.body.appendChild(overlay);
            document.body.appendChild(modal);
            modal.id = 'invalidRackModal';
        }
        
        function closeInvalidRackModal() {
            const modal = document.getElementById('invalidRackModal');
            const overlay = document.getElementById('invalidRackOverlay');
            if (modal) modal.remove();
            if (overlay) overlay.remove();
        }

        function copyPlayerLink() {
            const linkElement = document.querySelector('#playerLink a');
            const textToCopy = linkElement.textContent;
            
            // Crear elemento temporal para copiar
            const tempInput = document.createElement('input');
            tempInput.value = textToCopy;
            document.body.appendChild(tempInput);
            tempInput.select();
            document.execCommand('copy');
            document.body.removeChild(tempInput);
            
            // Cambiar temporalmente el texto del bot√≥n
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = '‚úÖ ¬°Copiado!';
            btn.style.background = '#27ae60';
            
            setTimeout(() => {
                btn.textContent = originalText;
            }, 2000);
        }
    </script>
    
    <!-- Modal para mostrar el leaderboard final -->
    <div id="finalLeaderboardModal" class="modal">
        <div class="modal-content">
            <h2 class="game-over-header">üéâ ¬°Juego Terminado! üéâ</h2>
            <p class="game-over-reason" id="gameOverReason"></p>
            
            <table class="final-leaderboard">
                <thead>
                    <tr>
                        <th>Posici√≥n</th>
                        <th>Jugador</th>
                        <th>Puntuaci√≥n Final</th>
                    </tr>
                </thead>
                <tbody id="finalLeaderboardBody">
                </tbody>
            </table>
            
            <button class="close-modal" onclick="closeFinalLeaderboard()">Cerrar</button>
        </div>
    </div>
    
    <script>
        // Funciones para el formulario de nuevo torneo
        function showNewTournamentForm() {
            document.getElementById('newTournamentForm').style.display = 'block';
        }
        
        // Funciones para el modal de cargar torneo
        async function showLoadTournamentModal() {
            const modal = document.getElementById('loadTournamentModal');
            modal.style.display = 'block';
            
            // Cargar lista de torneos
            const result = await apiCall('GET', '/tournaments');
            const listContainer = document.getElementById('tournamentsList');
            
            if (result.success && result.data && result.data.length > 0) {
                listContainer.innerHTML = result.data.map(tournament => {
                    const date = new Date(tournament.created_at);
                    const statusClass = tournament.status === 'Finished' ? 'finished' : 'active';
                    const statusText = tournament.status === 'Finished' ? 'Finalizado' : 'En Progreso';
                    
                    return `
                        <div class="tournament-item" onclick="loadTournament('${tournament.id}')">
                            <h4>${tournament.name}</h4>
                            <div class="info">
                                <strong>Creado:</strong> ${date.toLocaleDateString()} ${date.toLocaleTimeString()}
                                <span class="status ${statusClass}">${statusText}</span>
                            </div>
                            <div class="info">
                                <strong>Ronda actual:</strong> ${tournament.current_round} | 
                                <strong>Jugadores:</strong> ${tournament.players_count}
                            </div>
                        </div>
                    `;
                }).join('');
            } else {
                listContainer.innerHTML = '<p style="text-align: center; color: #6c757d;">No hay torneos guardados</p>';
            }
        }
        
        function closeLoadModal() {
            document.getElementById('loadTournamentModal').style.display = 'none';
        }
        
        async function loadTournament(tournamentId) {
            const result = await apiCall('POST', `/tournament/${tournamentId}/load`);
            
            if (result.success && result.data) {
                // Cerrar modal
                closeLoadModal();
                
                // Actualizar estado
                currentTournamentId = result.data.id;
                
                // Mostrar informaci√≥n del torneo
                document.getElementById('tournamentInfo').style.display = 'block';
                document.getElementById('tournamentId').textContent = result.data.id;
                document.getElementById('playerLink').querySelector('a').textContent = 
                    `${window.location.origin}/player.html?t=${result.data.id}`;
                document.getElementById('playerLink').querySelector('a').href = 
                    `/player.html?t=${result.data.id}`;
                
                // Ocultar formulario de nuevo torneo
                document.getElementById('newTournamentForm').style.display = 'none';
                
                // Actualizar estado global del torneo
                currentTournament = result.data;
                
                // Mostrar controles del juego
                document.getElementById('gameControlsTop').style.display = 'block';
                document.getElementById('gameInfo').style.display = 'block';
                document.getElementById('masterPlays').style.display = 'block';
                document.getElementById('bagTracking').style.display = 'block';
                
                // Actualizar bot√≥n universal seg√∫n el estado
                if (result.data.status === 'Finished') {
                    updateUniversalButton(BUTTON_STATES.GAME_OVER);
                } else if (result.data.rounds.length > 0) {
                    const lastRound = result.data.rounds[result.data.rounds.length - 1];
                    
                    // Si la √∫ltima ronda est√° completada, no hay ronda actual activa
                    if (lastRound.status === 'Completed') {
                        currentRound = null;
                    } else {
                        currentRound = lastRound;
                    }
                    
                    // Restaurar el tablero usando el √∫ltimo estado
                    // Buscar el board state m√°s reciente (puede estar en una ronda anterior si la actual est√° en progreso)
                    let boardToRestore = null;
                    for (let i = result.data.rounds.length - 1; i >= 0; i--) {
                        const round = result.data.rounds[i];
                        if (round.board_state && round.board_state.tiles) {
                            boardToRestore = round.board_state;
                            break;
                        }
                    }
                    
                    if (boardToRestore) {
                        restoreBoard(boardToRestore);
                    }
                    
                    // Mostrar el rack solo si la ronda NO est√° completada
                    if (lastRound.status !== 'Completed') {
                        if (lastRound.rack) {
                            displayRack(lastRound.rack);
                        }
                    } else {
                        // Ronda completada, limpiar el rack
                        const rackElement = document.getElementById('currentRack');
                        if (rackElement) {
                            rackElement.innerHTML = '';
                        }
                    }
                    
                    // Actualizar bot√≥n seg√∫n estado de la ronda
                    if (lastRound.status === 'Completed') {
                        updateUniversalButton(BUTTON_STATES.GENERATE_RACK);
                    } else if (lastRound.optimal_revealed) {
                        updateUniversalButton(BUTTON_STATES.GENERATE_RACK);
                    } else if (lastRound.timer_started) {
                        updateUniversalButton(BUTTON_STATES.REVEAL_PLAY);
                    } else {
                        updateUniversalButton(BUTTON_STATES.START_ROUND);
                    }
                } else {
                    updateUniversalButton(BUTTON_STATES.GENERATE_RACK);
                }
                
                // Restaurar jugadas del master
                if (result.data.master_plays && result.data.master_plays.length > 0) {
                    restoreMasterPlays(result.data.master_plays);
                }
                
                // Actualizar tabla de posiciones
                updateLeaderboard();
                
                // Actualizar tracking de bolsa
                updateBagDisplay();
                
                // Mostrar fichas de la bolsa
                updateBagTiles();
                
                alert(`Torneo "${result.data.name}" cargado exitosamente`);
            } else {
                alert('Error al cargar el torneo: ' + (result.error || 'Error desconocido'));
            }
        }
        
        function restoreBoard(boardState) {
            const board = document.getElementById('board');
            const cells = board.querySelectorAll('.cell');
            
            // Limpiar el tablero primero
            cells.forEach(cell => {
                cell.innerHTML = '';
                cell.classList.remove('has-tile');
            });
            
            // Restaurar cada ficha
            boardState.tiles.forEach((tile, index) => {
                if (tile && tile !== '') {
                    const cell = cells[index];
                    const tileDiv = document.createElement('div');
                    tileDiv.className = 'tile';
                    
                    // Detectar si es un blank (min√∫scula)
                    if (tile === tile.toLowerCase() && tile !== '?') {
                        tileDiv.classList.add('blank');
                        tileDiv.textContent = tile.toUpperCase();
                    } else {
                        tileDiv.textContent = tile;
                    }
                    
                    // Aplicar estilo de ficha de Scrabble
                    const tileValue = getTileValue(tile.toUpperCase());
                    if (tileValue > 0) {
                        tileDiv.innerHTML = `${tileDiv.textContent}<span class="tile-value">${tileValue}</span>`;
                    }
                    
                    cell.appendChild(tileDiv);
                    cell.classList.add('has-tile');
                }
            });
        }
        
        function restoreMasterPlays(masterPlays) {
            const tbody = document.querySelector('#masterPlaysTable tbody');
            tbody.innerHTML = ''; // Limpiar tabla
            
            masterPlays.forEach(play => {
                const row = document.createElement('tr');
                
                // Formato de posici√≥n
                const posFormat = play.position.down ? 
                    `${play.position.col + 1}${String.fromCharCode(65 + play.position.row)}‚Üì` :
                    `${String.fromCharCode(65 + play.position.row)}${play.position.col + 1}‚Üí`;
                
                row.innerHTML = `
                    <td>${play.round_number}</td>
                    <td>${play.word}</td>
                    <td>${posFormat}</td>
                    <td>${play.score}</td>
                    <td><strong>${play.cumulative_score}</strong></td>
                `;
                tbody.appendChild(row);
            });
        }
        
        // Cerrar modal al hacer click fuera
        window.onclick = function(event) {
            const modal = document.getElementById('loadTournamentModal');
            if (event.target === modal) {
                closeLoadModal();
            }
        }
    </script>
</body>
</html>