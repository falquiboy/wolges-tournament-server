<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Torneo de Scrabble Duplicado - v16</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        /* Modal para leaderboard final */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            animation: fadeIn 0.3s;
        }
        
        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 30px;
            border: 1px solid #888;
            width: 80%;
            max-width: 800px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            animation: slideIn 0.5s;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .game-over-header {
            text-align: center;
            font-size: 36px;
            color: #27ae60;
            margin-bottom: 20px;
            font-weight: bold;
        }
        
        .game-over-reason {
            text-align: center;
            font-size: 18px;
            color: #666;
            margin-bottom: 30px;
        }
        
        .final-leaderboard {
            width: 100%;
            margin: 20px 0;
        }
        
        .final-leaderboard th {
            background: #2c3e50;
            color: white;
            padding: 15px;
            font-size: 18px;
        }
        
        .final-leaderboard td {
            padding: 12px;
            font-size: 16px;
            text-align: center;
        }
        
        .final-leaderboard tr:nth-child(1) {
            background: #ffd700;
            font-weight: bold;
            font-size: 20px;
        }
        
        .final-leaderboard tr:nth-child(2) {
            background: #c0c0c0;
        }
        
        .final-leaderboard tr:nth-child(3) {
            background: #cd7f32;
        }
        
        .close-modal {
            background: #3498db;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            display: block;
            margin: 20px auto 0;
        }
        
        .close-modal:hover {
            background: #2980b9;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        h1 {
            text-align: center;
            color: white;
            font-size: 2.5em;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .game-layout {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 20px;
            align-items: start;
        }

        .panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        /* Tablero de Scrabble */
        .board-container {
            background: #2c3e50;
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            display: inline-block;
            position: relative;
        }
        
        .board-wrapper {
            display: grid;
            grid-template-columns: 30px 1fr 30px;
            grid-template-rows: 30px 1fr 30px;
            gap: 2px;
        }
        
        .board-grid {
            display: grid;
            grid-template-columns: repeat(15, 32px);
            gap: 0;
            background: #34495e;
            padding: 1px;
            grid-column: 2;
            grid-row: 2;
        }

        .coordinates {
            display: grid;
            gap: 2px;
        }
        
        .coordinates.top {
            grid-template-columns: repeat(15, 32px);
            grid-column: 2;
            grid-row: 1;
            gap: 0;
            padding: 0 1px;
        }
        
        .coordinates.bottom {
            grid-template-columns: repeat(15, 32px);
            grid-column: 2;
            grid-row: 3;
            gap: 0;
            padding: 0 1px;
        }
        
        .coordinates.left {
            grid-template-rows: repeat(15, 32px);
            grid-column: 1;
            grid-row: 2;
            gap: 0;
            padding: 1px 0;
        }
        
        .coordinates.right {
            grid-template-rows: repeat(15, 32px);
            grid-column: 3;
            grid-row: 2;
            gap: 0;
            padding: 1px 0;
        }

        .coord {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #ecf0f1;
            font-size: 12px;
            font-weight: bold;
        }
        
        .corner {
            width: 30px;
            height: 30px;
        }

        .board-row {
            display: contents;
        }

        .cell {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            background: #007778;
            color: white;
            border: none;
            box-shadow: inset 2px 2px 0 rgba(0,0,0,0.15), inset -2px -2px 0 rgba(255,255,255,0.15);
        }

        .cell:hover {
            transform: scale(1.1);
            z-index: 10;
        }

        /* Casillas premium */
        .tw { 
            background: #e53935 !important;
            color: white !important;
        }
        .dw { 
            background: #e5a2a0 !important;
            color: white !important;
        }
        .tl { 
            background: #408bf4 !important;
            color: white !important;
        }
        .dl { 
            background: #9dcaf0 !important;
            color: #2c3e50 !important;
        }
        .star { 
            background: #e5a2a0 !important;
            color: white !important;
        }

        .premium-label {
            font-size: 12px;
            font-weight: bold;
            opacity: 0.9;
            color: white !important;
        }

        /* Fichas colocadas */
        .cell.filled {
            background: #fef9d3 !important;
            color: #2d7a3e !important;
            outline: 1px solid #e8d7c3;
            outline-offset: -1px;
            font-size: 20px;
            border-radius: 2px;
            position: relative;
            padding-bottom: 3px;
            padding-right: 3px;
        }
        
        /* Tama√±o m√°s peque√±o para d√≠grafos */
        .cell.filled.digraph {
            font-size: 16px;
        }
        
        /* Comodines (letras min√∫sculas) */
        .cell.filled.blank {
            color: #e74c3c !important;
            font-weight: bold;
            text-transform: lowercase;
        }

        /* Valores de las fichas */
        .tile-value {
            position: absolute;
            bottom: 2px;
            right: 3px;
            font-size: 8px;
            font-weight: bold;
            color: #2d7a3e;
            line-height: 1;
        }

        .rack-tile .tile-value {
            font-size: 10px;
            bottom: 3px;
            right: 4px;
        }

        .cell.highlight {
            animation: shimmer 3s ease-in-out infinite;
            position: relative;
            overflow: hidden;
        }
        
        .cell.highlight::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, 
                transparent 30%, 
                rgba(255, 255, 255, 0.5) 50%, 
                transparent 70%);
            transform: translateX(-100%);
            animation: shine 3s ease-in-out infinite;
        }

        @keyframes shimmer {
            0% { 
                transform: scale(1) rotate(0deg);
                filter: brightness(0.85);
            }
            20% { 
                transform: scale(1.03) rotate(0.5deg);
                filter: brightness(0.9);
            }
            40% { 
                transform: scale(1.05) rotate(-0.5deg);
                filter: brightness(0.95);
            }
            50% { 
                transform: scale(1.05) rotate(0deg);
                filter: brightness(1);
            }
            60% { 
                transform: scale(1.03) rotate(0.5deg);
                filter: brightness(0.95);
            }
            80% { 
                transform: scale(1.01) rotate(0deg);
                filter: brightness(0.9);
            }
            100% { 
                transform: scale(1) rotate(0deg);
                filter: brightness(0.85);
            }
        }
        
        @keyframes shine {
            0% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
            100% { transform: translateX(100%); }
        }

        /* Atril */
        .rack-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 20px 0;
        }

        .rack {
            display: flex;
            gap: 8px;
            padding: 12px;
            background: #2d5a3d;
            border-radius: 10px;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.3);
            width: 440px;
            min-height: 72px;
            justify-content: center;
            align-items: center;
        }

        .rack-tile {
            width: 48px;
            height: 48px;
            background: #fef9d3;
            border: 1px solid #e8d7c3;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            font-weight: bold;
            color: #2d7a3e;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            flex-shrink: 0;
            position: relative;
            padding-bottom: 4px;
            padding-right: 4px;
        }
        
        /* Tama√±o m√°s peque√±o para d√≠grafos en rack */
        .rack-tile.digraph {
            font-size: 20px;
        }
        
        /* Animaci√≥n de deslizamiento para fichas */
        .rack-tile.slide-out {
            animation: slideOut 0.5s ease-out forwards;
        }
        
        .rack-tile.slide-in {
            animation: slideIn 0.5s ease-out forwards;
        }
        
        @keyframes slideOut {
            0% {
                transform: translateX(0);
                opacity: 1;
            }
            100% {
                transform: translateX(-100px);
                opacity: 0;
            }
        }
        
        @keyframes slideIn {
            0% {
                transform: translateX(100px);
                opacity: 0;
            }
            100% {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Botones */
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }

        button:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin: 15px 0;
        }

        /* Informaci√≥n del juego */
        .info-section {
            margin: 15px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .info-section h3 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        /* Jugada √≥ptima */
        .optimal-play {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        /* Tabla de posiciones */
        .leaderboard {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        .leaderboard th {
            background: #3498db;
            color: white;
            padding: 12px;
            text-align: left;
        }

        .leaderboard td {
            padding: 10px 12px;
            border-bottom: 1px solid #ddd;
        }

        .leaderboard tr:nth-child(even) {
            background: #f8f9fa;
        }

        .leaderboard tr:hover {
            background: #e3f2fd;
        }

        /* Estados */
        .status {
            padding: 10px 15px;
            border-radius: 6px;
            margin: 10px 0;
            font-weight: 500;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        /* Fichas de la bolsa */
        .bag-tiles {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            margin: 10px 0;
        }
        
        .bag-tile {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            border: 1px solid #d4a574;
            border-radius: 3px;
            background: #fff8dc;
            color: #2c3e50;
        }
        
        .bag-tile.used {
            opacity: 0.3;
            background: #e0e0e0;
        }
        
        /* Tabla del Master */
        .master-plays {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        
        .master-plays th {
            background: #f39c12;
            color: white;
            padding: 8px;
            text-align: left;
            font-size: 14px;
        }
        
        .master-plays td {
            padding: 6px 8px;
            border-bottom: 1px solid #ddd;
            font-size: 14px;
        }
        
        .master-plays tr:nth-child(even) {
            background: #fffaf0;
        }

        /* Responsive */
        @media (max-width: 1400px) {
            .game-layout {
                grid-template-columns: 1fr;
            }
            
            .board-container {
                order: 2;
                margin: 0 auto;
            }
            
            .panel {
                max-width: 600px;
                margin: 0 auto;
            }
        }

        /* Toggle bonus tags */
        .bonus-toggle {
            position: absolute;
            bottom: 8px;
            right: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
            color: #ecf0f1;
            font-size: 12px;
        }

        .toggle-switch {
            position: relative;
            width: 40px;
            height: 22px;
            background: #34495e;
            border-radius: 22px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: #3498db;
        }

        .toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }

        .toggle-switch.active .toggle-slider {
            transform: translateX(18px);
        }

        .premium-label.hidden, 
        .cell.star img.hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <h1>üéØ Torneo de Scrabble Duplicado üöÄ</h1>
        
        <div class="game-layout">
            <!-- Panel Izquierdo -->
            <div class="panel">
                <h2>Configuraci√≥n</h2>
                
                <div class="info-section">
                    <h3>1. Diccionario</h3>
                    <button onclick="loadDictionary()" id="loadDictBtn">Cargar FISE2016</button>
                    <div id="dictStatus"></div>
                </div>

                <div class="info-section">
                    <h3>2. Nuevo Torneo</h3>
                    <input type="text" id="tournamentName" placeholder="Nombre del torneo" 
                           value="Torneo de Cuates" style="width: 100%; padding: 8px; margin: 5px 0;">
                    <input type="text" id="playerNames" placeholder="Jugadores (separados por coma)" 
                           value="Juan, Mar√≠a, Carlos, Ana" style="width: 100%; padding: 8px; margin: 5px 0;">
                    <button onclick="createTournament()" id="createBtn">Crear Torneo</button>
                </div>

                <div class="info-section" id="tournamentInfo" style="display:none; background: #e8f6ff; border: 2px solid #3498db;">
                    <h3>üéÆ Torneo Creado</h3>
                    <div style="margin: 15px 0;">
                        <strong>ID del Torneo:</strong>
                        <div id="tournamentId" style="font-family: monospace; font-size: 14px; margin: 5px 0; padding: 5px; background: #fff; border: 1px solid #ddd; border-radius: 4px;"></div>
                    </div>
                    <div style="margin: 15px 0;">
                        <strong>Enlace para Jugadores:</strong>
                        <div id="playerLink" style="font-size: 14px; margin: 5px 0; padding: 8px; background: #fff; border: 1px solid #ddd; border-radius: 4px; word-break: break-all;">
                            <a href="#" target="_blank" style="color: #3498db;"></a>
                        </div>
                        <button onclick="copyPlayerLink()" style="background: #27ae60; padding: 5px 15px; font-size: 14px;">
                            üìã Copiar Enlace
                        </button>
                    </div>
                </div>

                <div class="info-section" id="gameControls" style="display:none;">
                    <h3>Control del Juego</h3>
                    <div class="button-group">
                        <button onclick="startNewRound()" id="newRoundBtn">Generar Atril de la Ronda 1</button>
                        <button onclick="undoLastRound()" id="undoBtn" style="background: #e74c3c;">
                            ‚Ü∂ Deshacer √öltima Ronda
                        </button>
                    </div>
                    <div id="manualRackInput" style="margin-top: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">
                            Entrada Manual (opcional):
                        </label>
                        <input type="text" id="manualRack" placeholder="Ej: CASA o CA?A (? = comod√≠n)" 
                               style="width: 70%; padding: 8px; text-transform: uppercase;"
                               oninput="validateManualRack()">
                        <button onclick="useManualRack()" id="useManualBtn" style="margin-left: 10px; background: #3498db;">
                            Usar Manual
                        </button>
                        <div id="rackValidationMessage" style="font-size: 12px; margin-top: 5px; min-height: 20px;">
                            <span style="color: #666;">Escriba las letras. Los d√≠grafos CH, LL, RR cuentan como 1 ficha.</span>
                        </div>
                    </div>
                    <div id="tilesRemaining" style="margin-top: 10px; font-weight: bold;"></div>
                </div>
                
                <div class="info-section" id="rackValidation" style="display:none;">
                    <h3>Validaci√≥n del Atril</h3>
                    <div id="validationInfo"></div>
                    <button onclick="rejectRack()" id="rejectBtn" class="reject-button" style="background: #e74c3c;">
                        Rechazar y Generar Nuevo
                    </button>
                    <button onclick="acceptRack()" id="acceptBtn" style="background: #27ae60;">
                        Aceptar Atril
                    </button>
                </div>
                
                <div class="info-section" id="timerControls" style="display:none;">
                    <h3>Tiempo de Reflexi√≥n</h3>
                    <div id="timer" style="font-size: 36px; text-align: center; margin: 20px 0;">3:00</div>
                    <button onclick="startTimer()" id="startTimerBtn">Iniciar 3 Minutos</button>
                    <button onclick="revealAndPlaceOptimalPlay()" id="revealPlayBtn" style="display:none; background: #27ae60;">
                        Revelar y Colocar Jugada √ìptima
                    </button>
                    <button onclick="checkAndShowFinalLeaderboard()" style="background: #e67e22; margin-top: 10px;">
                        üìä Ver Tabla Final
                    </button>
                </div>
            </div>

            <!-- Tablero Central -->
            <div class="board-container">
                <div class="bonus-toggle">
                    <span>Bonus</span>
                    <div class="toggle-switch active" id="bonusToggle" onclick="toggleBonusTags()">
                        <div class="toggle-slider"></div>
                    </div>
                </div>
                <div class="board-wrapper">
                    <!-- Esquina superior izquierda -->
                    <div class="corner" style="grid-column: 1; grid-row: 1;"></div>
                    
                    <!-- Coordenadas superiores (n√∫meros) -->
                    <div class="coordinates top">
                        <div class="coord">1</div>
                        <div class="coord">2</div>
                        <div class="coord">3</div>
                        <div class="coord">4</div>
                        <div class="coord">5</div>
                        <div class="coord">6</div>
                        <div class="coord">7</div>
                        <div class="coord">8</div>
                        <div class="coord">9</div>
                        <div class="coord">10</div>
                        <div class="coord">11</div>
                        <div class="coord">12</div>
                        <div class="coord">13</div>
                        <div class="coord">14</div>
                        <div class="coord">15</div>
                    </div>
                    
                    <!-- Esquina superior derecha -->
                    <div class="corner" style="grid-column: 3; grid-row: 1;"></div>
                    
                    <!-- Coordenadas izquierdas (letras) -->
                    <div class="coordinates left" id="leftCoords"></div>
                    
                    <!-- Tablero principal -->
                    <div id="board" class="board-grid"></div>
                    
                    <!-- Coordenadas derechas (letras) -->
                    <div class="coordinates right" id="rightCoords"></div>
                    
                    <!-- Esquina inferior izquierda -->
                    <div class="corner" style="grid-column: 1; grid-row: 3;"></div>
                    
                    <!-- Coordenadas inferiores (n√∫meros) -->
                    <div class="coordinates bottom">
                        <div class="coord">1</div>
                        <div class="coord">2</div>
                        <div class="coord">3</div>
                        <div class="coord">4</div>
                        <div class="coord">5</div>
                        <div class="coord">6</div>
                        <div class="coord">7</div>
                        <div class="coord">8</div>
                        <div class="coord">9</div>
                        <div class="coord">10</div>
                        <div class="coord">11</div>
                        <div class="coord">12</div>
                        <div class="coord">13</div>
                        <div class="coord">14</div>
                        <div class="coord">15</div>
                    </div>
                    
                    <!-- Esquina inferior derecha -->
                    <div class="corner" style="grid-column: 3; grid-row: 3;"></div>
                </div>
                
                <!-- Atril -->
                <div class="rack-container">
                    <div id="rack" class="rack" style="display:none;"></div>
                </div>
            </div>

            <!-- Panel Derecho -->
            <div class="panel">
                <h2>Informaci√≥n de la Ronda</h2>
                
                <div id="bagTilesContainer" style="display:none;">
                    <h3>Fichas de la Bolsa</h3>
                    <div id="bagTiles" class="bag-tiles"></div>
                </div>
                
                <div id="roundInfo"></div>
                <div id="optimalPlay"></div>
                
                <div id="masterPlaysContainer" style="display:none;">
                    <h3>üèÜ Jugador Master</h3>
                    <table id="masterPlays" class="master-plays">
                        <thead>
                            <tr>
                                <th>Ronda</th>
                                <th>Pos</th>
                                <th>Palabra</th>
                                <th>Puntos</th>
                                <th>Total</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
                
                <h3>Tabla de Posiciones</h3>
                <div id="leaderboard"></div>
            </div>
        </div>
    </div>

    <script>
        let currentTournamentId = null;
        let currentRound = null;
        let timerInterval = null;
        let timeRemaining = 180; // 3 minutos en segundos
        let optimalPlayData = null; // Almacenar jugada √≥ptima sin mostrar
        const API_BASE = window.location.origin;

        // Valores de las fichas del Scrabble espa√±ol
        const tileValues = {
            'A': 1, 'E': 1, 'I': 1, 'O': 1, 'U': 1, 'N': 1, 'R': 1, 'S': 1, 'T': 1, 'L': 1,
            'D': 2, 'G': 2,
            'B': 3, 'C': 3, 'M': 3, 'P': 3,
            'F': 4, 'H': 4, 'V': 4, 'Y': 4,
            'Q': 5,
            'J': 8, 'X': 8,
            'Z': 10,
            '√ë': 8,
            'CH': 5, 'LL': 8, 'RR': 8,
            '?': 0  // Comod√≠n
        };

        // Definir casillas premium
        const premiumSquares = {
            // Triple Word
            '0,0': 'tw', '0,7': 'tw', '0,14': 'tw',
            '7,0': 'tw', '7,14': 'tw',
            '14,0': 'tw', '14,7': 'tw', '14,14': 'tw',
            // Double Word
            '1,1': 'dw', '2,2': 'dw', '3,3': 'dw', '4,4': 'dw',
            '1,13': 'dw', '2,12': 'dw', '3,11': 'dw', '4,10': 'dw',
            '13,1': 'dw', '12,2': 'dw', '11,3': 'dw', '10,4': 'dw',
            '13,13': 'dw', '12,12': 'dw', '11,11': 'dw', '10,10': 'dw',
            '7,7': 'star',
            // Triple Letter
            '1,5': 'tl', '1,9': 'tl', '5,1': 'tl', '5,5': 'tl',
            '5,9': 'tl', '5,13': 'tl', '9,1': 'tl', '9,5': 'tl',
            '9,9': 'tl', '9,13': 'tl', '13,5': 'tl', '13,9': 'tl',
            // Double Letter
            '0,3': 'dl', '0,11': 'dl', '2,6': 'dl', '2,8': 'dl',
            '3,0': 'dl', '3,7': 'dl', '3,14': 'dl', '6,2': 'dl',
            '6,6': 'dl', '6,8': 'dl', '6,12': 'dl', '7,3': 'dl',
            '7,11': 'dl', '8,2': 'dl', '8,6': 'dl', '8,8': 'dl',
            '8,12': 'dl', '11,0': 'dl', '11,7': 'dl', '11,14': 'dl',
            '12,6': 'dl', '12,8': 'dl', '14,3': 'dl', '14,11': 'dl'
        };

        const premiumLabels = {
            'tw': '3P', 'dw': '2P', 'tl': '3L', 'dl': '2L', 'star': '‚ú¶'
        };

        async function apiCall(method, endpoint, body = null) {
            try {
                const options = {
                    method: method,
                    headers: { 'Content-Type': 'application/json' }
                };
                if (body) options.body = JSON.stringify(body);
                
                const response = await fetch(`${API_BASE}${endpoint}`, options);
                const data = await response.json();
                
                return data;
            } catch (error) {
                console.error('API Error:', error);
                return { success: false, error: error.message };
            }
        }

        function showStatus(message, type = 'success', elementId = null) {
            const html = `<div class="status ${type}">${message}</div>`;
            if (elementId) {
                document.getElementById(elementId).innerHTML = html;
            }
        }

        async function loadDictionary() {
            document.getElementById('loadDictBtn').disabled = true;
            const result = await apiCall('POST', '/dictionary/load', {
                kwg_path: 'FISE2016_converted.kwg',
                klv_path: null
            });
            
            if (result.success) {
                showStatus('‚úÖ Diccionario FISE2016 cargado', 'success', 'dictStatus');
                document.getElementById('loadDictBtn').textContent = '‚úì Cargado';
            } else {
                showStatus('‚ùå ' + result.error, 'error', 'dictStatus');
                document.getElementById('loadDictBtn').disabled = false;
            }
        }

        async function createTournament() {
            const name = document.getElementById('tournamentName').value;
            const playerNames = document.getElementById('playerNames').value
                .split(',')
                .map(n => n.trim())
                .filter(n => n);
            
            if (!name || playerNames.length < 1) {
                alert('Necesitas al menos 1 jugador');
                return;
            }
            
            const result = await apiCall('POST', '/tournament/create', {
                name: name,
                player_names: playerNames
            });
            
            if (result.success && result.data) {
                currentTournamentId = result.data.id;
                
                // Mostrar informaci√≥n del torneo
                document.getElementById('tournamentInfo').style.display = 'block';
                document.getElementById('tournamentId').textContent = currentTournamentId;
                
                const playerUrl = `${window.location.origin}/player.html?t=${currentTournamentId}`;
                const linkElement = document.querySelector('#playerLink a');
                linkElement.href = playerUrl;
                linkElement.textContent = playerUrl;
                
                document.getElementById('gameControls').style.display = 'block';
                document.getElementById('createBtn').disabled = true;
                document.getElementById('bagTilesContainer').style.display = 'block';
                document.getElementById('masterPlaysContainer').style.display = 'block';
                initializeBoard();
                updateLeaderboard();
                updateBagTiles();
                updateMasterPlays();
                updateRoundButton();
            }
        }

        function initializeBoard() {
            const board = document.getElementById('board');
            const leftCoords = document.getElementById('leftCoords');
            const rightCoords = document.getElementById('rightCoords');
            const letters = 'ABCDEFGHIJKLMNO';
            
            board.innerHTML = '';
            leftCoords.innerHTML = '';
            rightCoords.innerHTML = '';
            
            // Generar coordenadas laterales
            for (let row = 0; row < 15; row++) {
                // Coordenada izquierda
                const leftCoord = document.createElement('div');
                leftCoord.className = 'coord';
                leftCoord.textContent = letters[row];
                leftCoords.appendChild(leftCoord);
                
                // Coordenada derecha
                const rightCoord = document.createElement('div');
                rightCoord.className = 'coord';
                rightCoord.textContent = letters[row];
                rightCoords.appendChild(rightCoord);
                
                // Fila del tablero
                const boardRow = document.createElement('div');
                boardRow.className = 'board-row';
                
                // Celdas
                for (let col = 0; col < 15; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = `cell-${row * 15 + col}`;
                    
                    const premium = premiumSquares[`${row},${col}`];
                    if (premium) {
                        cell.classList.add(premium);
                        if (premium === 'star') {
                            const img = document.createElement('img');
                            img.src = 'black_star.png';
                            img.style.width = '20px';
                            img.style.height = '20px';
                            cell.appendChild(img);
                        } else {
                            const label = document.createElement('span');
                            label.className = 'premium-label';
                            label.textContent = premiumLabels[premium];
                            cell.appendChild(label);
                        }
                    }
                    
                    boardRow.appendChild(cell);
                }
                
                board.appendChild(boardRow);
            }
        }

        async function startNewRound() {
            if (!currentTournamentId) return;
            
            document.getElementById('newRoundBtn').disabled = true;
            const result = await apiCall('POST', `/tournament/${currentTournamentId}/round/start`);
            
            if (result.success && result.data) {
                currentRound = result.data;
                
                // Mostrar info de la ronda
                document.getElementById('roundInfo').innerHTML = `
                    <div class="info-section">
                        <h3>Ronda ${result.data.number}</h3>
                    </div>
                `;
                
                // Mostrar atril
                displayRack(result.data.rack);
                
                // Actualizar tablero
                updateBoard(result.data.board_state);
                
                // Mostrar validaci√≥n
                showRackValidation(result.data);
                
                // Actualizar fichas restantes
                updateTilesRemaining();
                updateBagTiles();
                
                document.getElementById('newRoundBtn').disabled = false;
            }
        }
        
        function showRackValidation(round) {
            const validationEl = document.getElementById('rackValidation');
            const validationInfo = document.getElementById('validationInfo');
            
            validationEl.style.display = 'block';
            
            // Contar tipos de fichas
            const tiles = round.rack.split('');
            const vowels = tiles.filter(t => 'AEIOU'.includes(t)).length;
            const consonants = tiles.filter(t => t !== '?' && !'AEIOU'.includes(t)).length;
            const blanks = tiles.filter(t => t === '?').length;
            
            let html = `
                <p><strong>Atril:</strong> ${round.rack}</p>
                <p>Vocales: ${vowels} | Consonantes: ${consonants} | Comodines: ${blanks}</p>
            `;
            
            if (round.rejection_reason) {
                html += `<p style="color: #e74c3c; font-weight: bold;">${round.rejection_reason}</p>`;
            } else if (round.number <= 15) {
                if (vowels <= 5 && consonants <= 5) {
                    html += `<p style="color: #27ae60;">‚úì Atril v√°lido</p>`;
                }
            } else {
                html += `<p style="color: #3498db;">Ronda ${round.number}: Sin restricciones</p>`;
            }
            
            validationInfo.innerHTML = html;
            
            // Ocultar timer hasta que se acepte
            document.getElementById('timerControls').style.display = 'none';
        }
        
        async function rejectRack() {
            console.log('rejectRack called', {currentTournamentId, currentRound});
            if (!currentTournamentId || !currentRound) {
                console.error('Missing tournament ID or round');
                return;
            }
            
            document.getElementById('rejectBtn').disabled = true;
            console.log('Calling reject_rack endpoint...');
            const result = await apiCall('PUT', `/tournament/${currentTournamentId}/round/${currentRound.number}/reject_rack`);
            console.log('Reject rack result:', result);
            
            if (result.success && result.data) {
                currentRound = result.data;
                displayRack(result.data.rack);
                showRackValidation(result.data);
                updateTilesRemaining();
                updateBagTiles();
            }
            
            document.getElementById('rejectBtn').disabled = false;
        }
        
        function acceptRack() {
            document.getElementById('rackValidation').style.display = 'none';
            document.getElementById('timerControls').style.display = 'block';
            
            // Obtener jugada √≥ptima mientras los jugadores piensan, pero no mostrarla
            getOptimalPlay(false);
        }
        
        async function updateTilesRemaining() {
            if (!currentTournamentId) return;
            
            const result = await apiCall('GET', `/tournament/${currentTournamentId}`);
            if (result.success && result.data) {
                document.getElementById('tilesRemaining').textContent = 
                    `Fichas en bolsa: ${result.data.tiles_remaining}`;
            }
        }
        
        async function startTimer() {
            // Primero, notificar al servidor que se inici√≥ el timer
            const result = await apiCall('PUT', `/tournament/${currentTournamentId}/round/${currentRound.number}/start_timer`);
            if (!result.success) {
                alert('Error al iniciar timer: ' + result.error);
                return;
            }
            
            timeRemaining = 180;
            document.getElementById('startTimerBtn').style.display = 'none';
            document.getElementById('revealPlayBtn').style.display = 'inline-block';
            
            timerInterval = setInterval(() => {
                timeRemaining--;
                const minutes = Math.floor(timeRemaining / 60);
                const seconds = timeRemaining % 60;
                document.getElementById('timer').textContent = 
                    `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                if (timeRemaining <= 0) {
                    clearInterval(timerInterval);
                    document.getElementById('timer').textContent = '0:00';
                    // Al terminar el tiempo, revelar y colocar autom√°ticamente
                    revealAndPlaceOptimalPlay();
                }
            }, 1000);
        }
        
        async function placeOptimalPlay() {
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            
            if (!currentTournamentId || !currentRound) return;
            
            // Actualizar el rack visual inmediatamente
            if (currentRound.optimal_play) {
                updateRackAfterPlay(currentRound.rack, currentRound.optimal_play.tiles_used);
            }
            
            // Colocar la jugada √≥ptima y actualizar el Master
            const result = await apiCall('PUT', 
                `/tournament/${currentTournamentId}/round/${currentRound.number}/place_optimal`);
            
            if (result.success) {
                // Reiniciar controles
                document.getElementById('timerControls').style.display = 'none';
                document.getElementById('startTimerBtn').style.display = 'inline-block';
                document.getElementById('placePlayBtn').style.display = 'none';
                document.getElementById('revealPlayBtn').style.display = 'none';
                document.getElementById('timer').textContent = '3:00';
                document.getElementById('optimalPlay').innerHTML = '';
                optimalPlayData = null;
                
                // Actualizar tabla del Master y fichas
                updateMasterPlays();
                updateBagTiles();
                updateRoundButton();
            }
        }

        function displayRack(rack) {
            const rackEl = document.getElementById('rack');
            rackEl.style.display = 'flex';
            rackEl.innerHTML = '';
            
            // Procesar el rack para manejar d√≠grafos
            let i = 0;
            while (i < rack.length) {
                let letter = rack[i];
                
                // Detectar d√≠grafos entre corchetes
                if (letter === '[') {
                    let j = i + 1;
                    while (j < rack.length && rack[j] !== ']') {
                        j++;
                    }
                    if (j < rack.length) {
                        // Extraer el d√≠grafo sin corchetes
                        letter = rack.substring(i + 1, j).toUpperCase();
                        i = j; // Saltar al ]
                    }
                }
                
                const tile = document.createElement('div');
                tile.className = 'rack-tile';
                tile.textContent = letter;
                
                // Detectar d√≠grafos
                if (letter.length > 1) {
                    tile.classList.add('digraph');
                }
                
                // Agregar valor de la ficha
                const value = tileValues[letter] || 0;
                if (value > 0) {
                    const valueSpan = document.createElement('span');
                    valueSpan.className = 'tile-value';
                    valueSpan.textContent = value;
                    tile.appendChild(valueSpan);
                }
                
                rackEl.appendChild(tile);
                i++;
            }
        }
        
        // Actualizar el rack visual mostrando solo las fichas restantes
        function updateRackAfterPlay(originalRack, tilesUsed) {
            console.log('updateRackAfterPlay called');
            console.log('Original rack:', originalRack);
            console.log('Tiles used:', tilesUsed);
            
            // Convertir el rack a array de fichas
            const rackTiles = [];
            let i = 0;
            while (i < originalRack.length) {
                let letter = originalRack[i];
                
                if (letter === '[') {
                    let j = i + 1;
                    while (j < originalRack.length && originalRack[j] !== ']') {
                        j++;
                    }
                    if (j < originalRack.length) {
                        // Incluir los corchetes para la comparaci√≥n
                        letter = originalRack.substring(i, j + 1);
                        i = j;
                    }
                }
                
                rackTiles.push(letter);
                i++;
            }
            
            console.log('Parsed rack tiles:', rackTiles);
            
            // Crear copia del rack para remover fichas usadas
            const remainingTiles = [...rackTiles];
            
            // Remover las fichas usadas
            for (const usedTile of tilesUsed) {
                if (usedTile && usedTile !== '') {
                    console.log('Removing tile:', usedTile);
                    let index = remainingTiles.findIndex(tile => tile === usedTile);
                    
                    // Si no encontramos la ficha exacta, podr√≠a ser un comod√≠n usado como esa letra
                    if (index === -1 && remainingTiles.includes('?')) {
                        // Verificar si la letra usada no est√° en el rack original
                        const originalHasThisTile = rackTiles.filter(t => t === usedTile).length > 0;
                        const alreadyRemovedCount = rackTiles.filter(t => t === usedTile).length - 
                                                   remainingTiles.filter(t => t === usedTile).length;
                        
                        // Si ya removimos todas las instancias de esta letra que estaban en el rack original,
                        // entonces debe ser un comod√≠n
                        if (!originalHasThisTile || alreadyRemovedCount >= rackTiles.filter(t => t === usedTile).length) {
                            index = remainingTiles.findIndex(tile => tile === '?');
                            if (index !== -1) {
                                console.log('Using blank tile (?) for:', usedTile);
                            }
                        }
                    }
                    
                    if (index !== -1) {
                        remainingTiles.splice(index, 1);
                        console.log('Removed tile at index:', index);
                    } else {
                        console.log('Tile not found in remaining tiles:', usedTile);
                    }
                }
            }
            
            console.log('Remaining tiles after removal:', remainingTiles);
            
            // Animar las fichas actuales saliendo
            const currentTiles = rackEl.querySelectorAll('.rack-tile');
            currentTiles.forEach((tile, index) => {
                tile.classList.add('slide-out');
            });
            
            // Esperar a que termine la animaci√≥n de salida
            setTimeout(() => {
                rackEl.innerHTML = '';
                
                if (remainingTiles.length === 0) {
                    // Rack vac√≠o
                    const emptyMsg = document.createElement('div');
                    emptyMsg.style.color = '#999';
                    emptyMsg.style.fontSize = '14px';
                    emptyMsg.style.textAlign = 'center';
                    emptyMsg.style.width = '100%';
                    emptyMsg.textContent = '(Rack vac√≠o - se usaron todas las fichas)';
                    rackEl.appendChild(emptyMsg);
                } else {
                    // Mostrar fichas restantes con animaci√≥n de entrada
                    remainingTiles.forEach((tile, index) => {
                        const tileEl = document.createElement('div');
                        tileEl.className = 'rack-tile slide-in';
                        // Quitar corchetes para display
                        const cleanTile = tile.replace(/[\[\]]/g, '');
                        tileEl.textContent = cleanTile;
                        
                        // Detectar d√≠grafos
                        if (cleanTile.length > 1) {
                            tileEl.classList.add('digraph');
                        }
                        
                        // Agregar valor de la ficha
                        const value = tileValues[cleanTile] || 0;
                        if (value > 0) {
                            const valueSpan = document.createElement('span');
                            valueSpan.className = 'tile-value';
                            valueSpan.textContent = value;
                            tileEl.appendChild(valueSpan);
                        }
                        
                        // Retrasar la animaci√≥n de entrada para cada ficha
                        tileEl.style.animationDelay = `${index * 0.1}s`;
                        
                        rackEl.appendChild(tileEl);
                    });
            }
        }

        function updateBoard(boardState) {
            // Limpiar highlights anteriores
            document.querySelectorAll('.cell').forEach(cell => {
                cell.classList.remove('filled', 'highlight', 'blank');
            });
            
            boardState.tiles.forEach((tile, index) => {
                const cell = document.getElementById(`cell-${index}`);
                if (cell && tile) {
                    // Detectar si es un comod√≠n (letra min√∫scula)
                    const isBlank = tile.length === 1 && tile === tile.toLowerCase() && tile !== tile.toUpperCase();
                    
                    // Limpiar d√≠grafos
                    const cleanTile = tile.replace(/\[([^\]]+)\]/g, '$1').toUpperCase();
                    cell.textContent = cleanTile;
                    cell.classList.add('filled');
                    
                    // Detectar d√≠grafos
                    if (cleanTile.length > 1) {
                        cell.classList.add('digraph');
                    }
                    
                    // Agregar valor de la ficha
                    const value = tileValues[cleanTile] || 0;
                    if (value > 0 && !isBlank) {
                        const valueSpan = document.createElement('span');
                        valueSpan.className = 'tile-value';
                        valueSpan.textContent = value;
                        cell.appendChild(valueSpan);
                    }
                    
                    if (isBlank) {
                        cell.classList.add('blank');
                    }
                }
            });
        }

        async function getOptimalPlay(showImmediately = true) {
            if (!currentTournamentId || !currentRound) return;
            
            const result = await apiCall('GET', 
                `/tournament/${currentTournamentId}/round/${currentRound.number}/optimal`);
            
            if (result.success && result.data) {
                optimalPlayData = result.data;
                console.log('Optimal play data received:', optimalPlayData);
                
                if (showImmediately) {
                    displayOptimalPlay();
                }
            }
        }
        
        function displayOptimalPlay() {
            if (!optimalPlayData) return;
            
            const play = optimalPlayData;
            // Limpiar d√≠grafos pero preservar may√∫sculas/min√∫sculas para comodines
            let displayWord = '';
            for (let i = 0; i < play.word.length; i++) {
                if (play.word[i] === '[' && play.word.indexOf(']', i) !== -1) {
                    // Handle digraph - always uppercase
                    const end = play.word.indexOf(']', i);
                    const digraph = play.word.substring(i + 1, end);
                    displayWord += digraph.toUpperCase();
                    i = end;
                } else {
                    // Preserve case for blanks
                    displayWord += play.word[i];
                }
            }
            
            document.getElementById('optimalPlay').innerHTML = `
                <div class="optimal-play">
                    <h4>üèÜ Jugada √ìptima</h4>
                    <strong>${displayWord}</strong> - ${play.score} puntos<br>
                    <small>
                        ${getCoordinate(play.position.row, play.position.col, play.position.down)} 
                        ${play.position.down ? '‚Üì' : '‚Üí'}
                    </small>
                </div>
            `;
            
            // Animar la jugada √≥ptima
            highlightPlay(play);
        }
        
        async function revealAndPlaceOptimalPlay() {
            if (!currentTournamentId || !currentRound) return;
            
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            
            // Primero revelar la jugada √≥ptima
            await apiCall('PUT', `/tournament/${currentTournamentId}/round/${currentRound.number}/reveal_optimal`);
            
            // Mostrar la jugada √≥ptima
            displayOptimalPlay();
            
            // Esperar un momento para que el usuario vea la jugada
            setTimeout(async () => {
                // Actualizar el rack visual inmediatamente usando optimalPlayData
                if (optimalPlayData && optimalPlayData.tiles_used) {
                    updateRackAfterPlay(currentRound.rack, optimalPlayData.tiles_used);
                }
                
                // Luego colocarla
                const result = await apiCall('PUT', 
                    `/tournament/${currentTournamentId}/round/${currentRound.number}/place_optimal`);
                
                if (result.success) {
                    // Reiniciar controles
                    document.getElementById('timerControls').style.display = 'none';
                    document.getElementById('startTimerBtn').style.display = 'inline-block';
                    document.getElementById('revealPlayBtn').style.display = 'none';
                    document.getElementById('timer').textContent = '3:00';
                    document.getElementById('optimalPlay').innerHTML = '';
                    optimalPlayData = null;
                    
                    // Actualizar tabla del Master y fichas
                    updateMasterPlays();
                    updateBagTiles();
                    updateRoundButton();
                    
                    // Verificar si el juego termin√≥
                    checkGameEnd();
                }
            }, 2000); // Esperar 2 segundos para que se vea la jugada
        }

        function getCoordinate(row, col, isDown) {
            // En Scrabble, el orden de coordenadas indica direcci√≥n:
            // Horizontal (‚Üí): Fila + Columna (ej: H8)
            // Vertical (‚Üì): Columna + Fila (ej: 8H)
            const letters = 'ABCDEFGHIJKLMNO';
            if (isDown) {
                // Vertical: columna (n√∫mero) + fila (letra)
                return `${col + 1}${letters[row]}`;
            } else {
                // Horizontal: fila (letra) + columna (n√∫mero)
                return `${letters[row]}${col + 1}`;
            }
        }

        function highlightPlay(play) {
            console.log('highlightPlay - word:', play.word, 'tiles_used:', play.tiles_used);
            const start = play.position.row * 15 + play.position.col;
            
            // Build the word without anchors to check for blanks
            let wordWithoutAnchors = '';
            let wordIndex = 0;
            
            // First pass: build the word without anchors
            for (let i = 0; i < play.word.length; i++) {
                if (play.word[i] === '(' && play.word.indexOf(')', i) !== -1) {
                    // Skip anchor
                    i = play.word.indexOf(')', i);
                } else if (play.word[i] === '[' && play.word.indexOf(']', i) !== -1) {
                    // Handle digraph
                    const end = play.word.indexOf(']', i);
                    wordWithoutAnchors += play.word.substring(i, end + 1);
                    i = end;
                } else {
                    wordWithoutAnchors += play.word[i];
                }
            }
            
            console.log('Word without anchors:', wordWithoutAnchors);
            
            // Now highlight tiles
            wordIndex = 0;
            play.tiles_used.forEach((tile, index) => {
                if (tile) {
                    // Check if this tile corresponds to a lowercase letter in the word
                    let isBlank = false;
                    
                    // Find the corresponding character in wordWithoutAnchors
                    if (wordIndex < wordWithoutAnchors.length) {
                        const char = wordWithoutAnchors[wordIndex];
                        // Check if it's a lowercase letter (blank)
                        isBlank = char === char.toLowerCase() && char !== char.toUpperCase();
                        
                        // Handle digraphs
                        if (wordWithoutAnchors[wordIndex] === '[') {
                            const endBracket = wordWithoutAnchors.indexOf(']', wordIndex);
                            wordIndex = endBracket + 1;
                        } else {
                            wordIndex++;
                        }
                    }
                    
                    console.log('Tile:', tile, 'isBlank:', isBlank);
                    
                    // Limpiar d√≠grafos
                    const cleanTile = tile.replace(/\[([^\]]+)\]/g, '$1').toUpperCase();
                    
                    const cellIndex = play.position.down ? 
                        start + (index * 15) : 
                        start + index;
                    const cell = document.getElementById(`cell-${cellIndex}`);
                    if (cell) {
                        cell.classList.add('highlight');
                        setTimeout(() => {
                            cell.textContent = cleanTile;
                            cell.classList.add('filled');
                            
                            // Detectar d√≠grafos
                            if (cleanTile.length > 1) {
                                cell.classList.add('digraph');
                            }
                            
                            // Agregar valor de la ficha
                            const value = tileValues[cleanTile] || 0;
                            if (value > 0 && !isBlank) {
                                const valueSpan = document.createElement('span');
                                valueSpan.className = 'tile-value';
                                valueSpan.textContent = value;
                                cell.appendChild(valueSpan);
                            }
                            
                            if (isBlank) {
                                cell.classList.add('blank');
                                console.log('Added blank class to cell', cellIndex);
                            }
                        }, 300);
                    }
                }
            });
        }

        async function updateLeaderboard() {
            if (!currentTournamentId) return;
            
            const result = await apiCall('GET', `/tournament/${currentTournamentId}/leaderboard`);
            
            if (result.success && result.data) {
                const leaderboard = document.getElementById('leaderboard');
                leaderboard.innerHTML = `
                    <table class="leaderboard">
                        <thead>
                            <tr>
                                <th>Pos</th>
                                <th>Jugador</th>
                                <th>Puntos</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${result.data.map((player, index) => `
                                <tr>
                                    <td>${index + 1}</td>
                                    <td>${player.name}</td>
                                    <td>${player.total_score}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
            }
        }

        async function updateBagTiles() {
            if (!currentTournamentId) {
                console.log('No tournament ID for bag tiles');
                return;
            }
            
            console.log('Fetching bag tiles for tournament:', currentTournamentId);
            const result = await apiCall('GET', `/tournament/${currentTournamentId}/bag_tiles`);
            
            console.log('Bag tiles result:', result);
            
            if (result.success && result.data) {
                const bagTilesEl = document.getElementById('bagTiles');
                bagTilesEl.innerHTML = '';
                
                console.log('Tracking all', result.data.length, 'tiles in game (used and available)');
                
                // Agrupar fichas por letra
                const tileGroups = {};
                result.data.forEach(([tile, used]) => {
                    // Limpiar d√≠grafos de corchetes
                    if (tile.startsWith('[') && tile.endsWith(']')) {
                        tile = tile.substring(1, tile.length - 1).toUpperCase();
                    }
                    
                    if (!tileGroups[tile]) {
                        tileGroups[tile] = { total: 0, used: 0 };
                    }
                    tileGroups[tile].total++;
                    if (used) tileGroups[tile].used++;
                });
                
                console.log('Tile groups:', tileGroups);
                
                // Mostrar fichas ordenadas - Spanish alphabet order
                const spanishOrder = ['?', 'A', 'B', 'C', 'CH', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'L', 'LL', 'M', 'N', '√ë', 'O', 'P', 'Q', 'R', 'RR', 'S', 'T', 'U', 'V', 'X', 'Y', 'Z'];
                const sortedTiles = Object.keys(tileGroups).sort((a, b) => {
                    const cleanA = a.replace(/\[|\]/g, '');
                    const cleanB = b.replace(/\[|\]/g, '');
                    return spanishOrder.indexOf(cleanA) - spanishOrder.indexOf(cleanB);
                });
                sortedTiles.forEach(tile => {
                    const group = tileGroups[tile];
                    // Primero las no usadas
                    for (let i = 0; i < group.total - group.used; i++) {
                        const tileEl = document.createElement('div');
                        tileEl.className = 'bag-tile';
                        // Remove brackets for display
                        tileEl.textContent = tile.replace(/\[([^\]]+)\]/g, '$1');
                        bagTilesEl.appendChild(tileEl);
                    }
                    // Luego las usadas (atenuadas)
                    for (let i = 0; i < group.used; i++) {
                        const tileEl = document.createElement('div');
                        tileEl.className = 'bag-tile used';
                        // Remove brackets for display
                        tileEl.textContent = tile.replace(/\[([^\]]+)\]/g, '$1');
                        bagTilesEl.appendChild(tileEl);
                    }
                });
            } else {
                console.error('Failed to get bag tiles:', result.error);
            }
        }
        
        async function updateMasterPlays() {
            if (!currentTournamentId) return;
            
            const result = await apiCall('GET', `/tournament/${currentTournamentId}`);
            
            if (result.success && result.data) {
                const masterPlays = result.data.master_plays || [];
                const tbody = document.querySelector('#masterPlays tbody');
                tbody.innerHTML = '';
                
                masterPlays.forEach(play => {
                    // Limpiar d√≠grafos en la palabra
                    const cleanWord = play.word.replace(/\[([^\]]+)\]/g, '$1').toUpperCase();
                    
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${play.round_number}</td>
                        <td>${getCoordinate(play.position.row, play.position.col, play.position.down)}${play.position.down ? '‚Üì' : '‚Üí'}</td>
                        <td><strong>${cleanWord}</strong></td>
                        <td>${play.score}</td>
                        <td><strong>${play.cumulative_score}</strong></td>
                    `;
                    tbody.appendChild(row);
                });
            }
        }
        
        async function updateRoundButton() {
            if (!currentTournamentId) return;
            
            const result = await apiCall('GET', `/tournament/${currentTournamentId}`);
            if (result.success && result.data) {
                const nextRound = result.data.rounds.length + 1;
                document.getElementById('newRoundBtn').textContent = `Generar Atril de la Ronda ${nextRound}`;
            }
        }
        
        function countTilesInRack(rack) {
            // Contar fichas considerando d√≠grafos
            let count = 0;
            let i = 0;
            while (i < rack.length) {
                if (i < rack.length - 1) {
                    const digraph = rack.substring(i, i + 2);
                    if (digraph === 'CH' || digraph === 'LL' || digraph === 'RR') {
                        count++;
                        i += 2;
                        continue;
                    }
                }
                count++;
                i++;
            }
            return count;
        }
        
        function validateManualRack() {
            const input = document.getElementById('manualRack').value.trim().toUpperCase();
            const validationMsg = document.getElementById('rackValidationMessage');
            const useBtn = document.getElementById('useManualBtn');
            
            if (!input) {
                validationMsg.innerHTML = '<span style="color: #666;">Escriba las letras. Los d√≠grafos CH, LL, RR cuentan como 1 ficha.</span>';
                useBtn.disabled = false;
                return;
            }
            
            const tileCount = countTilesInRack(input);
            
            if (tileCount < 7) {
                validationMsg.innerHTML = `<span style="color: #f39c12;">Tiene ${tileCount} fichas. Necesita ${7 - tileCount} m√°s.</span>`;
                useBtn.disabled = true;
            } else if (tileCount > 7) {
                validationMsg.innerHTML = `<span style="color: #e74c3c;">Tiene ${tileCount} fichas. Quite ${tileCount - 7}.</span>`;
                useBtn.disabled = true;
            } else {
                // Mostrar las fichas que se usar√°n
                let fichas = [];
                let i = 0;
                while (i < input.length) {
                    if (i < input.length - 1) {
                        const digraph = input.substring(i, i + 2);
                        if (digraph === 'CH' || digraph === 'LL' || digraph === 'RR') {
                            fichas.push(digraph);
                            i += 2;
                            continue;
                        }
                    }
                    fichas.push(input[i]);
                    i++;
                }
                validationMsg.innerHTML = `<span style="color: #27ae60;">‚úì 7 fichas: ${fichas.join(' ')}</span>`;
                useBtn.disabled = false;
            }
        }
        
        async function useManualRack() {
            const manualRackInput = document.getElementById('manualRack').value.trim().toUpperCase();
            
            if (!manualRackInput) {
                alert('Por favor ingrese las fichas del atril');
                return;
            }
            
            if (!currentTournamentId) {
                alert('Primero debe crear un torneo');
                return;
            }
            
            // Procesar el input para manejar d√≠grafos
            let processedRack = manualRackInput
                .replace(/CH/g, '[CH]')
                .replace(/LL/g, '[LL]')
                .replace(/RR/g, '[RR]');
            
            // Validar longitud usando la misma funci√≥n
            const tileCount = countTilesInRack(manualRackInput);
            
            if (tileCount !== 7) {
                // Esto no deber√≠a pasar si el bot√≥n est√° deshabilitado correctamente
                alert(`El atril debe tener exactamente 7 fichas (tiene ${tileCount})`);
                return;
            }
            
            // Llamar al servidor con el atril manual
            const result = await apiCall('POST', `/tournament/${currentTournamentId}/round/start_manual`, {
                rack: processedRack
            });
            
            if (result.success && result.data) {
                currentRound = result.data;
                
                // Mostrar info de la ronda
                document.getElementById('roundInfo').innerHTML = `
                    <div class="info-section">
                        <h3>Ronda ${result.data.number}</h3>
                        <p style="color: #3498db;">Atril ingresado manualmente</p>
                    </div>
                `;
                
                // Mostrar atril
                displayRack(result.data.rack);
                
                // Actualizar tablero
                updateBoard(result.data.board_state);
                
                // Mostrar validaci√≥n
                showRackValidation(result.data);
                
                // Actualizar fichas restantes
                updateTilesRemaining();
                updateBagTiles();
                
                // Limpiar el input
                document.getElementById('manualRack').value = '';
            } else {
                alert('Error: ' + (result.error || 'No se pudo usar el atril manual'));
            }
        }
        
        async function undoLastRound() {
            if (!currentTournamentId) return;
            
            if (!confirm('¬øEst√°s seguro de que quieres deshacer la √∫ltima ronda completada?')) {
                return;
            }
            
            const result = await apiCall('PUT', `/tournament/${currentTournamentId}/undo`);
            
            if (result.success) {
                // Limpiar estado actual
                currentRound = null;
                optimalPlayData = null;
                document.getElementById('optimalPlay').innerHTML = '';
                document.getElementById('roundInfo').innerHTML = '';
                document.getElementById('rack').style.display = 'none';
                document.getElementById('rackValidation').style.display = 'none';
                document.getElementById('timerControls').style.display = 'none';
                
                // Recargar el estado del torneo
                const tournamentResult = await apiCall('GET', `/tournament/${currentTournamentId}`);
                if (tournamentResult.success && tournamentResult.data) {
                    // Reconstruir el tablero basado en las jugadas maestras restantes
                    initializeBoard();
                    
                    // Aplicar todas las jugadas maestras al tablero
                    for (const play of tournamentResult.data.master_plays) {
                        applyPlayToBoard(play);
                    }
                    
                    // Actualizar UI
                    updateMasterPlays();
                    updateBagTiles();
                    updateRoundButton();
                    
                    alert('Se deshizo la √∫ltima ronda exitosamente');
                }
            } else {
                alert('Error: ' + (result.error || 'No se pudo deshacer la ronda'));
            }
        }
        
        function applyPlayToBoard(play) {
            const start = play.position.row * 15 + play.position.col;
            
            // Parse the word to get individual tiles
            let tiles = [];
            let i = 0;
            while (i < play.word.length) {
                if (play.word[i] === '(' && play.word.indexOf(')', i) !== -1) {
                    // Skip anchor tiles
                    i = play.word.indexOf(')', i) + 1;
                } else if (play.word[i] === '[' && play.word.indexOf(']', i) !== -1) {
                    // Handle digraphs
                    const end = play.word.indexOf(']', i);
                    tiles.push(play.word.substring(i, end + 1));
                    i = end + 1;
                } else {
                    tiles.push(play.word[i]);
                    i++;
                }
            }
            
            // Apply tiles to board
            let tileIndex = 0;
            for (let j = 0; j < tiles.length; j++) {
                const tile = tiles[j];
                if (tile && tile !== '(' && tile !== ')') {
                    const cellIndex = play.position.down ? 
                        start + (tileIndex * 15) : 
                        start + tileIndex;
                    
                    const cell = document.getElementById(`cell-${cellIndex}`);
                    if (cell) {
                        const isBlank = tile === tile.toLowerCase() && tile !== tile.toUpperCase();
                        const cleanTile = tile.replace(/\[([^\]]+)\]/g, '$1').toUpperCase();
                        
                        cell.textContent = cleanTile;
                        cell.classList.add('filled');
                        
                        // Detectar d√≠grafos
                        if (cleanTile.length > 1) {
                            cell.classList.add('digraph');
                        }
                        
                        // Agregar valor de la ficha
                        const value = tileValues[cleanTile] || 0;
                        if (value > 0 && !isBlank) {
                            const valueSpan = document.createElement('span');
                            valueSpan.className = 'tile-value';
                            valueSpan.textContent = value;
                            cell.appendChild(valueSpan);
                        }
                        
                        if (isBlank) {
                            cell.classList.add('blank');
                        }
                    }
                    tileIndex++;
                }
            }
        }
        
        // Toggle bonus tags visibility
        function toggleBonusTags() {
            const toggle = document.getElementById('bonusToggle');
            toggle.classList.toggle('active');
            
            const labels = document.querySelectorAll('.premium-label');
            
            if (toggle.classList.contains('active')) {
                labels.forEach(label => label.classList.remove('hidden'));
            } else {
                labels.forEach(label => label.classList.add('hidden'));
            }
        }

        // Inicializar tablero vac√≠o al cargar
        window.onload = () => {
            initializeBoard();
        };
        
        async function checkGameEnd() {
            if (!currentTournamentId) return;
            
            const result = await apiCall('GET', `/tournament/${currentTournamentId}/check_end`);
            if (result.success && result.data) {
                if (result.data.game_ended) {
                    showFinalLeaderboard(result.data.reason);
                }
            }
        }
        
        async function showFinalLeaderboard(reason) {
            // Obtener leaderboard final con Master incluido
            const tournamentResult = await apiCall('GET', `/tournament/${currentTournamentId}`);
            if (!tournamentResult.success) return;
            
            const tournament = tournamentResult.data;
            const leaderboardResult = await apiCall('GET', `/tournament/${currentTournamentId}/leaderboard`);
            if (!leaderboardResult.success) return;
            
            const players = leaderboardResult.data;
            
            // Calcular puntuaci√≥n del Master
            const masterScore = tournament.master_plays.reduce((sum, play) => sum + play.score, 0);
            
            // Agregar Master al leaderboard
            const allPlayers = [...players, { name: 'Master', total_score: masterScore }];
            allPlayers.sort((a, b) => b.total_score - a.total_score);
            
            // Crear y mostrar modal
            const modal = document.getElementById('finalLeaderboardModal');
            const tbody = document.getElementById('finalLeaderboardBody');
            const reasonEl = document.getElementById('gameOverReason');
            
            reasonEl.textContent = reason || 'Juego terminado';
            
            tbody.innerHTML = allPlayers.map((player, index) => `
                <tr>
                    <td>${index + 1}</td>
                    <td>${player.name}</td>
                    <td>${player.total_score}</td>
                </tr>
            `).join('');
            
            modal.style.display = 'block';
            
            // Guardar estado del juego
            document.getElementById('newRoundBtn').disabled = true;
            document.getElementById('newRoundBtn').textContent = 'Juego Terminado';
        }
        
        function closeFinalLeaderboard() {
            document.getElementById('finalLeaderboardModal').style.display = 'none';
        }
        
        async function checkAndShowFinalLeaderboard() {
            // Verificar primero si el juego termin√≥
            const result = await apiCall('GET', `/tournament/${currentTournamentId}/check_end`);
            if (result.success && result.data) {
                showFinalLeaderboard(result.data.reason || 'Tabla de posiciones actual');
            }
        }
        
        function copyPlayerLink() {
            const linkElement = document.querySelector('#playerLink a');
            const textToCopy = linkElement.textContent;
            
            // Crear elemento temporal para copiar
            const tempInput = document.createElement('input');
            tempInput.value = textToCopy;
            document.body.appendChild(tempInput);
            tempInput.select();
            document.execCommand('copy');
            document.body.removeChild(tempInput);
            
            // Cambiar temporalmente el texto del bot√≥n
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = '‚úÖ ¬°Copiado!';
            btn.style.background = '#27ae60';
            
            setTimeout(() => {
                btn.textContent = originalText;
            }, 2000);
        }
    </script>
    
    <!-- Modal para mostrar el leaderboard final -->
    <div id="finalLeaderboardModal" class="modal">
        <div class="modal-content">
            <h2 class="game-over-header">üéâ ¬°Juego Terminado! üéâ</h2>
            <p class="game-over-reason" id="gameOverReason"></p>
            
            <table class="final-leaderboard">
                <thead>
                    <tr>
                        <th>Posici√≥n</th>
                        <th>Jugador</th>
                        <th>Puntuaci√≥n Final</th>
                    </tr>
                </thead>
                <tbody id="finalLeaderboardBody">
                </tbody>
            </table>
            
            <button class="close-modal" onclick="closeFinalLeaderboard()">Cerrar</button>
        </div>
    </div>
</body>
</html>